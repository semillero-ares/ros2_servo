{"config":{"indexing":"full","lang":["es"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"BRAZO ROB\u00d3TICO CONTROLADO POR ROS 2 1.1. Introducci\u00f3n Un brazo rob\u00f3tico SCARA 4 DOF es un tipo de robot industrial utilizado para la automatizaci\u00f3n de procesos y la fabricaci\u00f3n de artefactos. Esta m\u00e1quina ser\u00e1 controlada por una plataforma de c\u00f3digo llamada ROS 2 que es una herramienta de desarrollo de software empleada en la rob\u00f3tica 1.2. Descripci\u00f3n del proyecto Este documento explora las posibilidades de trabajar con un marco de rob\u00f3tica, concretamente ROS 2, para interconectar diversas posibilidades en este complejo \u00e1mbito. ROS 2 ofrece facilidad para conectar sistemas de detecci\u00f3n y actuaci\u00f3n, facilitando el procesamiento de datos para una mejor toma de decisiones y acelerando los procesos. La segunda versi\u00f3n de ROS 2 es la preferida, ya que recibir\u00e1 los comentarios de los creadores, lo que la convertir\u00e1 en el futuro del sector. ROS 2 tambi\u00e9n ofrece descentralizaci\u00f3n, permitiendo que m\u00faltiples nodos con la misma importancia trabajen juntos. Para sumergirse mejor en ROS, es esencial trabajar con un modelo f\u00edsico, incluidos los microcontroladores y la visi\u00f3n rob\u00f3tica, utilizando el robot industrial que se encuentra en la Universidad EAFIT bloque 19 planta 2. 1.3. Objetivos de proyecto - Simular el robot industrial encontrado en el segundo piso del bloque 19 de la Universidad en el ambiente de simulaci\u00f3n Gazebo 2. - Tener un modelo preciso con respecto al original para tener una simulaci\u00f3n concreta del robot. - Crear las diferentes poses necesarias para tener un proceso industrial en la mesa de trabajo utilizando una m\u00e1quina de estados finitos (MEF). - Implementar la visi\u00f3n rob\u00f3tica en el equipo para mejorar la precisi\u00f3n del proceso. 1.4. Etapas del proyecto - Proceso de modelado y simulaci\u00f3n. - Caracterizaci\u00f3n del robot SCARA. - Conexi\u00f3n con ROS y Arduino. - Visi\u00f3n rob\u00f3tica para procesos complejos. Requisitos principales del proyecto - Se requieren conocimientos b\u00e1sicos de _ROS 2_. - Herramientas de visualizaci\u00f3n gr\u00e1fica como: _gazebo, rviz, moveit, entre otras. En el presente documento se encuentra la bit\u00e1cora con todos los pasos para lograr el objetivo del proyecto, el repositorio de _github_ se encuentra a continuaci\u00f3n: Repositorio Github","title":"Home"},{"location":"#brazo-robotico-controlado-por-ros-2","text":"","title":"BRAZO ROB\u00d3TICO CONTROLADO POR ROS 2"},{"location":"#11-introduccion","text":"Un brazo rob\u00f3tico SCARA 4 DOF es un tipo de robot industrial utilizado para la automatizaci\u00f3n de procesos y la fabricaci\u00f3n de artefactos. Esta m\u00e1quina ser\u00e1 controlada por una plataforma de c\u00f3digo llamada ROS 2 que es una herramienta de desarrollo de software empleada en la rob\u00f3tica","title":"1.1. Introducci\u00f3n"},{"location":"#12-descripcion-del-proyecto","text":"Este documento explora las posibilidades de trabajar con un marco de rob\u00f3tica, concretamente ROS 2, para interconectar diversas posibilidades en este complejo \u00e1mbito. ROS 2 ofrece facilidad para conectar sistemas de detecci\u00f3n y actuaci\u00f3n, facilitando el procesamiento de datos para una mejor toma de decisiones y acelerando los procesos. La segunda versi\u00f3n de ROS 2 es la preferida, ya que recibir\u00e1 los comentarios de los creadores, lo que la convertir\u00e1 en el futuro del sector. ROS 2 tambi\u00e9n ofrece descentralizaci\u00f3n, permitiendo que m\u00faltiples nodos con la misma importancia trabajen juntos. Para sumergirse mejor en ROS, es esencial trabajar con un modelo f\u00edsico, incluidos los microcontroladores y la visi\u00f3n rob\u00f3tica, utilizando el robot industrial que se encuentra en la Universidad EAFIT bloque 19 planta 2.","title":"1.2. Descripci\u00f3n del proyecto"},{"location":"#13-objetivos-de-proyecto","text":"- Simular el robot industrial encontrado en el segundo piso del bloque 19 de la Universidad en el ambiente de simulaci\u00f3n Gazebo 2. - Tener un modelo preciso con respecto al original para tener una simulaci\u00f3n concreta del robot. - Crear las diferentes poses necesarias para tener un proceso industrial en la mesa de trabajo utilizando una m\u00e1quina de estados finitos (MEF). - Implementar la visi\u00f3n rob\u00f3tica en el equipo para mejorar la precisi\u00f3n del proceso.","title":"1.3. Objetivos de proyecto"},{"location":"#14-etapas-del-proyecto","text":"- Proceso de modelado y simulaci\u00f3n. - Caracterizaci\u00f3n del robot SCARA. - Conexi\u00f3n con ROS y Arduino. - Visi\u00f3n rob\u00f3tica para procesos complejos.","title":"1.4. Etapas del proyecto"},{"location":"#requisitos-principales-del-proyecto","text":"- Se requieren conocimientos b\u00e1sicos de _ROS 2_. - Herramientas de visualizaci\u00f3n gr\u00e1fica como: _gazebo, rviz, moveit, entre otras. En el presente documento se encuentra la bit\u00e1cora con todos los pasos para lograr el objetivo del proyecto, el repositorio de _github_ se encuentra a continuaci\u00f3n: Repositorio Github","title":"Requisitos principales del proyecto"},{"location":"1-0-Ros2%20installation/","text":"1. Ros2 Installation for Ubuntu Here is a condensed version of the official tutorial to install ROS2 on Ubuntu. We must follow a series of commands in the terminal: Setup Sources Verify the locale using: locale As a result, UTF-8 is obtained in all cases. LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=es_CO.UTF-8 LC_TIME=es_CO.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=es_CO.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=es_CO.UTF-8 LC_NAME=es_CO.UTF-8 LC_ADDRESS=es_CO.UTF-8 LC_TELEPHONE=es_CO.UTF-8 LC_MEASUREMENT=es_CO.UTF-8 LC_IDENTIFICATION=es_CO.UTF-8 LC_ALL= Otherwise we must use: sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings We will activate the universe repository: sudo apt install software-properties-common sudo add-apt-repository universe We install git and other packages: sudo apt install git sudo apt install libserial-dev We will add the security key for the ROS2 repository: sudo apt update && sudo apt install curl -y sudo curl -ssl https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg Add the ROS2 repository to the repository list: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null Install ROS 2 packages We update the list and update the installed software: sudo apt update && sudo apt upgrade We install ROS2 humble version: sudo apt install ros-humble-desktop We install ROS2 packages that we will use: sudo apt install ros-humble-gazebo-ros-pkgs sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gazebo-ros2-control sudo apt install ros-humble-moveit ros-humble-moveit-resources -y Install Colcon: sudo apt install python3-colcon-common-extensions -y Environment setup Finally, we configure the terminal to identify the ROS2 commands: echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc Verify the installation We restart the terminal and then we can test that we have ROS2 correctly installed and running: In terminal 1: source /opt/ros/humble/setup.bash ros2 run demo_nodes_cpp talker In terminal 2: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py listener Troubleshooting When running ROS2 commands that open a graphical interface like the following: ros2 run rviz2 rviz2 An error may take place: /opt/ros/humble/lib/rviz2/rviz2: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory [ros2run]: Process exited with failure 127 to solve it we use the following command: sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5","title":"1. Ros2 Installation for Ubuntu"},{"location":"1-0-Ros2%20installation/#1-ros2-installation-for-ubuntu","text":"Here is a condensed version of the official tutorial to install ROS2 on Ubuntu. We must follow a series of commands in the terminal:","title":"1. Ros2 Installation for Ubuntu"},{"location":"1-0-Ros2%20installation/#setup-sources","text":"Verify the locale using: locale As a result, UTF-8 is obtained in all cases. LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=es_CO.UTF-8 LC_TIME=es_CO.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=es_CO.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=es_CO.UTF-8 LC_NAME=es_CO.UTF-8 LC_ADDRESS=es_CO.UTF-8 LC_TELEPHONE=es_CO.UTF-8 LC_MEASUREMENT=es_CO.UTF-8 LC_IDENTIFICATION=es_CO.UTF-8 LC_ALL= Otherwise we must use: sudo apt update && sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 export LANG=en_US.UTF-8 locale # verify settings We will activate the universe repository: sudo apt install software-properties-common sudo add-apt-repository universe We install git and other packages: sudo apt install git sudo apt install libserial-dev We will add the security key for the ROS2 repository: sudo apt update && sudo apt install curl -y sudo curl -ssl https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg Add the ROS2 repository to the repository list: echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null","title":"Setup Sources"},{"location":"1-0-Ros2%20installation/#install-ros-2-packages","text":"We update the list and update the installed software: sudo apt update && sudo apt upgrade We install ROS2 humble version: sudo apt install ros-humble-desktop We install ROS2 packages that we will use: sudo apt install ros-humble-gazebo-ros-pkgs sudo apt install ros-humble-ros2-control ros-humble-ros2-controllers ros-humble-gazebo-ros2-control sudo apt install ros-humble-moveit ros-humble-moveit-resources -y Install Colcon: sudo apt install python3-colcon-common-extensions -y","title":"Install ROS 2 packages"},{"location":"1-0-Ros2%20installation/#environment-setup","text":"Finally, we configure the terminal to identify the ROS2 commands: echo \"source /opt/ros/humble/setup.bash\" >> ~/.bashrc","title":"Environment setup"},{"location":"1-0-Ros2%20installation/#verify-the-installation","text":"We restart the terminal and then we can test that we have ROS2 correctly installed and running: In terminal 1: source /opt/ros/humble/setup.bash ros2 run demo_nodes_cpp talker In terminal 2: source /opt/ros/humble/setup.bash ros2 run demo_nodes_py listener","title":"Verify the installation"},{"location":"1-0-Ros2%20installation/#troubleshooting","text":"When running ROS2 commands that open a graphical interface like the following: ros2 run rviz2 rviz2 An error may take place: /opt/ros/humble/lib/rviz2/rviz2: error while loading shared libraries: libQt5Core.so.5: cannot open shared object file: No such file or directory [ros2run]: Process exited with failure 127 to solve it we use the following command: sudo strip --remove-section=.note.ABI-tag /usr/lib/x86_64-linux-gnu/libQt5Core.so.5","title":"Troubleshooting"},{"location":"2-0-Requisitos/","text":"2. Requisitos software Para la realizaci\u00f3n del proyecto se tienen los siguientes requisitos de software: Tener instalado Ubuntu ya sea de sistema operativo origen o VM, en este caso se realiz\u00f3 con WSL siguiendo este tutorial Instalar ROS2 Humble Instalar ROS2 Control Instalar un editor de c\u00f3digo como Visual Studio Code Tener cuenta en Github e instalar git para windows en el caso de usar WSL, con esto se podr\u00e1n subir los cambios desde Visual Studio Code muy f\u00e1cilmente Estos son los requisitos claves para la elaboraci\u00f3n del proyecto; sin embargo, instalaciones adicionales se mencionar\u00e1n a medida que se necesiten m\u00e1s adelante.","title":"2. Requisitos software"},{"location":"2-0-Requisitos/#2-requisitos-software","text":"Para la realizaci\u00f3n del proyecto se tienen los siguientes requisitos de software: Tener instalado Ubuntu ya sea de sistema operativo origen o VM, en este caso se realiz\u00f3 con WSL siguiendo este tutorial Instalar ROS2 Humble Instalar ROS2 Control Instalar un editor de c\u00f3digo como Visual Studio Code Tener cuenta en Github e instalar git para windows en el caso de usar WSL, con esto se podr\u00e1n subir los cambios desde Visual Studio Code muy f\u00e1cilmente Estos son los requisitos claves para la elaboraci\u00f3n del proyecto; sin embargo, instalaciones adicionales se mencionar\u00e1n a medida que se necesiten m\u00e1s adelante.","title":"2. Requisitos software"},{"location":"3-0-primerosPasosRos/","text":"3. Primeros pasos con ROS 3.1. Creando un paquete en ROS Todo el desarrollo del proyecto ser\u00e1 realizado en la plataforma ROS , en el caso de nunca haber trabajado con ROS, se recomienda seguir los tutoriales disponibles en la Documentaci\u00f3n o ver el siguiente video para obtener conceptos b\u00e1sicos de esta herramienta. Cuando se trabaja en ROS, b\u00e1sicamente se tiene una carpeta global llamada Workspace en la que se encuentran varias carpetas pero la m\u00e1s importante es una llamada src , all\u00ed se encuentran a su vez m\u00e1s carpetas conocidas como packages o paquetes, estos paquetes contienen todos los scripts necesarios para realizar una tarea. Por ejemplo, podemos tener un package para solamente visualizar el robot en rviz , o para moverlo en gazebo ; es decir, el n\u00famero de paquetes depende directamente del desarrollador. Para crear un paquete se puede utilizar un propio comando de ubuntu ros2 pkg create my_first_package ... estos paquetes pueden crearse ya sea en Python o en C++ , esto depender\u00e1 del desarrollador; adem\u00e1s, se deben especificar las dependecias del paquete para no ocasionar ning\u00fan error; sin embargo, en el caso de no especificarlas completamente, se pueden a\u00f1adir despu\u00e9s sin ning\u00fan problema. En este orden de ideas para comenzar con la creacion de todo se seguir\u00edan los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Crear paquete ros2 pkg create my_first_package --build-type ament_python --dependencies rclpy Con esto ya tendr\u00edas el paquete creado, ser\u00eda un paquete vac\u00edo hasta el momento. Lo siguiente ser\u00eda compilar el paquete, al compilarlo se crear\u00e1n varias carpetas en el workspace: log , install y build , para compilar basta con escribir el comando colcon build , en el caso de no tenerlo instalado simplemente sigue el comando que te recomeinda la terminal de ubuntu. Cabe resaltar que todo esto puedes hacerlo desde la terminal nativa de WSL o para mas facilidad desde Visual Studio Code al abrir una de tipo Ubuntu(WSL) . 3.2. Clonar un paquete de Github A pesar de que el proceso anterior no sea tan tedioso, otra opci\u00f3n para crear un paquete puede ser utilizando una plantilla de Github y adaptarla a tus necesidades. Para esto basta con seguir los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Clonar git clone https://github.com/Ph0n1x0/my_bot.git , esta plantilla es la utilizada en el canal de referencia previamente mencionado. Con esto ya tendr\u00edas una plantilla lista para modificar. Es importante mencionar que cada que cambies script del paquete debes usar el comando colcon build y source install/setup.bash TIP: Si utilizas el comando colcon build --symlink-install compilar\u00e1 automaticamente los cambios en los scripts, solamente NO compilar\u00e1 cuando crees nuevos documentos o archivos.","title":"3. Primeros pasos con ROS"},{"location":"3-0-primerosPasosRos/#3-primeros-pasos-con-ros","text":"","title":"3. Primeros pasos con ROS"},{"location":"3-0-primerosPasosRos/#31-creando-un-paquete-en-ros","text":"Todo el desarrollo del proyecto ser\u00e1 realizado en la plataforma ROS , en el caso de nunca haber trabajado con ROS, se recomienda seguir los tutoriales disponibles en la Documentaci\u00f3n o ver el siguiente video para obtener conceptos b\u00e1sicos de esta herramienta. Cuando se trabaja en ROS, b\u00e1sicamente se tiene una carpeta global llamada Workspace en la que se encuentran varias carpetas pero la m\u00e1s importante es una llamada src , all\u00ed se encuentran a su vez m\u00e1s carpetas conocidas como packages o paquetes, estos paquetes contienen todos los scripts necesarios para realizar una tarea. Por ejemplo, podemos tener un package para solamente visualizar el robot en rviz , o para moverlo en gazebo ; es decir, el n\u00famero de paquetes depende directamente del desarrollador. Para crear un paquete se puede utilizar un propio comando de ubuntu ros2 pkg create my_first_package ... estos paquetes pueden crearse ya sea en Python o en C++ , esto depender\u00e1 del desarrollador; adem\u00e1s, se deben especificar las dependecias del paquete para no ocasionar ning\u00fan error; sin embargo, en el caso de no especificarlas completamente, se pueden a\u00f1adir despu\u00e9s sin ning\u00fan problema. En este orden de ideas para comenzar con la creacion de todo se seguir\u00edan los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Crear paquete ros2 pkg create my_first_package --build-type ament_python --dependencies rclpy Con esto ya tendr\u00edas el paquete creado, ser\u00eda un paquete vac\u00edo hasta el momento. Lo siguiente ser\u00eda compilar el paquete, al compilarlo se crear\u00e1n varias carpetas en el workspace: log , install y build , para compilar basta con escribir el comando colcon build , en el caso de no tenerlo instalado simplemente sigue el comando que te recomeinda la terminal de ubuntu. Cabe resaltar que todo esto puedes hacerlo desde la terminal nativa de WSL o para mas facilidad desde Visual Studio Code al abrir una de tipo Ubuntu(WSL) .","title":"3.1. Creando un paquete en ROS"},{"location":"3-0-primerosPasosRos/#32-clonar-un-paquete-de-github","text":"A pesar de que el proceso anterior no sea tan tedioso, otra opci\u00f3n para crear un paquete puede ser utilizando una plantilla de Github y adaptarla a tus necesidades. Para esto basta con seguir los siguientes pasos: Crear Workspace mkdir robot_ws Crear carpeta src cd robot_ws mkdir src cd src Clonar git clone https://github.com/Ph0n1x0/my_bot.git , esta plantilla es la utilizada en el canal de referencia previamente mencionado. Con esto ya tendr\u00edas una plantilla lista para modificar. Es importante mencionar que cada que cambies script del paquete debes usar el comando colcon build y source install/setup.bash TIP: Si utilizas el comando colcon build --symlink-install compilar\u00e1 automaticamente los cambios en los scripts, solamente NO compilar\u00e1 cuando crees nuevos documentos o archivos.","title":"3.2. Clonar un paquete de Github"},{"location":"4-0-Comunicaci%C3%B3n%20serial/","text":"4. Comunicaci\u00f3n serial en WSL En WSL necesitaremos instalar esto . O tendremos que generar una comunicaci\u00f3n serial falsa de la siguiente forma socat -d -d pty,rawer,echo=0 pty,rawer,echo=0 En mi caso aparecieron los puertos seriales /dev/pts/3 y /dev/pts/4 ... los cuales pueden ser usados en el archivo de configuraci\u00f3n de ros2_control. Conexi\u00f3n por TCP al serial de Windows Para conectarnos por TCP a un serial de Windows desde nuestro Ubuntu WSL, vamos a usar dos programas, uno en windows y otro en linux, En windows podremos usar: TCPCOM32 , se instala y se configura como server. com0com m\u00e1s referencias aqu\u00ed En linux podremos usar multiples opciones: ser2net bash sudo apt-get install ser2net socat ( ref-2 ) REVISAR Como vamos a estar trabajando con Arduino, la configuraci\u00f3n serial de este es: SERIAL_8N1 : Comunicaci\u00f3n serial de 8 Bits, Sin paridad (N), con un bit de parada.","title":"4. Comunicaci\u00f3n serial en WSL"},{"location":"4-0-Comunicaci%C3%B3n%20serial/#4-comunicacion-serial-en-wsl","text":"En WSL necesitaremos instalar esto . O tendremos que generar una comunicaci\u00f3n serial falsa de la siguiente forma socat -d -d pty,rawer,echo=0 pty,rawer,echo=0 En mi caso aparecieron los puertos seriales /dev/pts/3 y /dev/pts/4 ... los cuales pueden ser usados en el archivo de configuraci\u00f3n de ros2_control.","title":"4. Comunicaci\u00f3n serial en WSL"},{"location":"4-0-Comunicaci%C3%B3n%20serial/#conexion-por-tcp-al-serial-de-windows","text":"Para conectarnos por TCP a un serial de Windows desde nuestro Ubuntu WSL, vamos a usar dos programas, uno en windows y otro en linux, En windows podremos usar: TCPCOM32 , se instala y se configura como server. com0com m\u00e1s referencias aqu\u00ed En linux podremos usar multiples opciones: ser2net bash sudo apt-get install ser2net socat ( ref-2 ) REVISAR Como vamos a estar trabajando con Arduino, la configuraci\u00f3n serial de este es: SERIAL_8N1 : Comunicaci\u00f3n serial de 8 Bits, Sin paridad (N), con un bit de parada.","title":"Conexi\u00f3n por TCP al serial de Windows"},{"location":"4-1-URDF/","text":"5. URDF Un archivo URDF es un archivo xacro que describe un componente de un robot, ya sea su descripci\u00f3n puramente f\u00edsica, inercial, de controladores, etc. El que toma m\u00e1s tiempo siempre es el URDF general del robot porque describe toda la configuraci\u00f3n y topolog\u00eda del mismo, para obtener este archivo se pueden tomar dos alternativas: 1. Crear URDF con figuras b\u00e1sicas como cubos y cilindros, este m\u00e9todo suele ser \u00f3ptimo para robots sencillos como un servomotor. 2. Extraer URDF de un software de modelaci\u00f3n como _SolidWorks_, para esto se debe tener el ensamble total de la m\u00e1quina/robot que se desea controlar, este m\u00e9todo es \u00f3ptimo para robots m\u00e1s complejos. En este caso se mostrar\u00e1n brevemente los pasos que se llevaron en el canal de referencia para hacer el URDF del robot diferencial con figuras geom\u00e9tricas y un ejemplo en solidworks con un servomotor extra\u00eddo de _Grabcad_. 5.1. Setup Para crear el archivo URDF, debe cumplir los siguientes pasos: Tener ROS2 instalado Tener creado un workspace Tener copiada la plantilla de Github Instalar xacro: sudo apt install ros-humble-xacro Instalar joint state publisher: sudo apt install ros-humble-joint-state-publisher-gui Los archivos de configuraci\u00f3n de un robot se escriben en _xacro_, estos archivos son conocidos como archivos de descripci\u00f3n del robot, los documentos se procesan mediante _xacro_ obteniendo un solo archivo URDF que llega a un nodo llamado _robot state publisher_, este nodo convierte los archivos en un _/robotdescription_ y genera todas las transformaciones de las juntas (joints) mediante _/tf_. Con esto, si deseamos mover las articulaciones del robot podemos utilizar _joint state publisher gui_ para visualizar el funcionamiento del robot. 5.2. Ejemplo URDF con Robot diferencial Un robot diferencial es un robot que principalmente est\u00e1 formado por dos ruedas conocidas como _driven wheels_ (una en cada lado), estas dos ruedas son responables de _TODO_ el movimiento del robot; por lo que, todas las dem\u00e1s solamente son para _mantener estable_ el robot conocidas como _caster wheels_. Con esta imagen se puede decir que el robot en realidad puede llegar a ser una _caja_ que tiene a sus lados un par de ruedas de direcci\u00f3n junto con otra rueda de estabilizaci\u00f3n. Para el comienzo del desarrollo del robot se plantean dos cosas: El enlace ra\u00edz (Root link) debe llamarse base link La orientaci\u00f3n de las uniones debe ser: +x delante, +y izquierda, +z arriba 5.2.1. Creando un archivo URDF En la plantilla clonada anteriormente se tiene el siguiente archivo inicial de URDF: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <!-- Example link --> <link name=\"base_link\"> Con este URDF de esta manera al utilizar el comando `ros2 launch my_bot rsp.launch.py` se podr\u00e1 visualizar el \u00fanico link que tiene especificado el URDF. Lo que normalmente se hace es que en un archivo xacro se incluyen dem\u00e1s archivos xacro que contienen distinta informaci\u00f3n como el URDF, el controlador, componentes como c\u00e1mara o dispositivos, etc. Por lo que este archivo base se puede modificar de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <xacro:include filename=\"robot_core.xacro\" /> </robot> Este archivo estar\u00e1 llamando a `robot_core.xacro`, un xacro creado en la misma carpeta que contendr\u00e1 el URDF del robot. Con esto ya se puede crear el archivo URDF del robot, primero se crean los materiales del robot de esta manera: <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> Luego empieza _TODA_ la constituci\u00f3n del robot, esto quiere decir todos los _joints_ y _links_ que este mismo contiene comenzando por el _base link_ y _chassis_: <!-- BASE LINK --> <link name=\"base_link\"> </link> Los joints pueden ser de distintos tipos, tales como: prismatic, revolute, fixed, continuous, etc ; adem\u00e1s, se definen con un parent , child y origin : <!-- CHASSIS LINK --> <joint name=\"chassis_joint\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"chassis\"/> <origin xyz=\"-0.1 0 0\"/> </joint> Luego de definir el joint se procede a definir el link del robot en el que primero se define el _visual_ como una caja de 300x300x150mm (todos los par\u00e1metros de ROS se encuentran siempre en sistema m\u00e9trico internacional) con su respectivo origen y material previamente definido. Luego, se define la _collision_ , que basicamente es el mismo contenido del _visual_ sin el _material_; por \u00faltimo, se define su inercia, en este caso se est\u00e1 incluyendo otro archivo xacro en donde se define una macro llamada `inertial_box`, esta macro se define en otro archivo que se llamar\u00e1 `inertial_macros.xacro` y se incluir\u00e1 de igual manera que se incluy\u00f3 el `robot_core.xacro` <!-- ESTO IR\u00cdA AL INICIO DEL C\u00d3DIGO URDF --> <xacro:include filename=\"inertial_macros.xacro\"/> <!-- Archivo de inertial_macros --> <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> <link name=\"chassis\"> <visual> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> <material name=\"white\"/> </visual> <collision> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.5\" x=\"0.3\" y=\"0.3\" z=\"0.15\"> <origin xyz=\"0.15 0 0.075\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> De esta manera se sigue con las dos ruedas del robot, solamente que los joints ser\u00e1n de tipo _continuous_ y en vez de utilizar una geometr\u00eda de _box_ se utilizar\u00e1 un _cylinder_ (adem\u00e1s de definir origines e inercias). <!-- LEFT WHEEL LINK --> <joint name=\"left_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"left_wheel\"/> <origin xyz=\"0 0.175 0\" rpy=\"-${pi/2} 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"left_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> <!-- RIGHT WHEEL LINK --> <joint name=\"right_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"right_wheel\"/> <origin xyz=\"0 -0.175 0\" rpy=\"${pi/2} 0 0\" /> <axis xyz=\"0 0 -1\"/> </joint> <link name=\"right_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> Luego de misma manera con la caster wheel con un joint tipo fixed y una geometr\u00eda de sphere : <!-- CASTER WHEEL LINK --> <joint name=\"caster_wheel_joint\" type=\"fixed\"> <parent link=\"chassis\"/> <child link=\"caster_wheel\"/> <origin xyz=\"0.24 0 0\"/> </joint> <link name=\"caster_wheel\"> <visual> <geometry> <sphere radius=\"0.05\"/> </geometry> <material name=\"black\"/> </visual> <collision> <geometry> <sphere radius=\"0.05\"/> </geometry> </collision> <xacro:inertial_sphere mass=\"0.1\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_sphere> </link> </robot> Con todo esto ya creado ya se podr\u00eda visualizar el robot sin ning\u00fan problema, solo har\u00eda falta compilar colcon build --symlink-install y source install/setup.bash . Despu\u00e9s de esto al correr el comando ros2 launch my_bot rsp.launch.py y en una terminal nueva ros2 run joint_state_publisher_gui joint_state_publisher_gui se podr\u00eda visualizar el robot y mover las ruedas seg\u00fan la definici\u00f3n del URDF. 5.3. Ejemplo Servomotor URDF con Plugin de SolidWorks Un servomotor SG90 es un tipo de motor el\u00e9ctrico que se utiliza para controlar la posici\u00f3n, velocidad y aceleraci\u00f3n con precisi\u00f3n; este elemento al tener 1 DOF permite conocer e identificar los pasos a realizar para controlar el robot SCARA al tener una estructura muy similar. Para realizar una simulaci\u00f3n del elemento en movimiento se requiere de un URDF y si se tiene el elemento modelado, SolidWorks posee un plugin que brinda un archivo URDF. PASOS Instalar sw2urdfSETUP.exe para la versi\u00f3n de SolidWorks que se tenga instalado. Instalar plugin de SolidWorks Abrir la pieza en SolidWorks. En la parte superior derecha de la pantalla, se busca la extensi\u00f3n. Se definen las barras o eslabones que presenta el elemento, en este caso, se fja la base como la barra de tierra (inmovil), y se definen los eslabones y pares cinem\u00e1ticos como las partes moviles. Se presiona la opci\u00f3n de \"Preview and export URDF\" y se definen las variablees que posee el elemento, luego se genera el URDF y las mallas del elemento. EJEMPLO DEL URDF EXPORTADO <?xml version=\"1.0\"?> <robot name=\"servo7\"> <link name=\"base\"> <inertial> <origin xyz=\"-6.7573E-06 0.011598 5.6311E-08\" rpy=\"6 0 0\" /> <mass value=\"0.0064019\" /> <inertia ixx=\"3.4577E-07\" ixy=\"-2.7463E-10\" ixz=\"4.3013E-12\" iyy=\"3.8183E-07\" iyz=\"2.2886E-12\" izz=\"5.7895E-07\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> </collision> </link> <link name=\"plu_chasis\"> <inertial> <origin xyz=\"0.001818 -5.3648E-05 -0.0015\" rpy=\"0 0 0\" /> <mass value=\"0.00035175\" /> <inertia ixx=\"3.232E-09\" ixy=\"1.5994E-25\" ixz=\"1.252E-25\" iyy=\"7.3777E-09\" iyz=\"-1.8232E-25\" izz=\"1.0082E-08\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> <material name=\"\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> </collision> </link> <joint name=\"joint1\" type=\"fixed\"> <origin xyz=\"-0.00409 0.0227 0\" rpy=\"1.5708 -0.007929 0\" /> <parent link=\"base\" /> <child link=\"plu_chasis\" /> <axis xyz=\"0 0 0\" /> </joint> <link name=\"eje\"> <inertial> <origin xyz=\"6.3741E-05 0.0031 4.638E-05\" rpy=\"0 0 0\" /> <mass value=\"0.00010538\" /> <inertia ixx=\"6.1365E-10\" ixy=\"-1.9311E-27\" ixz=\"-2.6707E-26\" iyy=\"3.168E-10\" iyz=\"-1.2874E-27\" izz=\"6.1365E-10\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.5 0.5 0.5 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> </collision> </link> <joint name=\"joint2\" type=\"continuous\"> <origin xyz=\"-0.00415 0.0232 -0.0001\" rpy=\"0 0 0\" /> <parent link=\"base\" /> <child link=\"eje\" /> <axis xyz=\"0 1 0\" /> <dynamics friction=\"0.1\" /> </joint> <link name=\"plumilla\"> <inertial> <origin xyz=\"0.0042098 5.9689E-05 -0.0021514\" rpy=\"0 0 0\" /> <mass value=\"0.00011261\" /> <inertia ixx=\"4.3387E-10\" ixy=\"-6.7617E-11\" ixz=\"2.3634E-10\" iyy=\"2.941E-09\" iyz=\"6.3694E-12\" izz=\"3.2007E-09\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"1.0 0.41 0.71 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> </collision> </link> <joint name=\"joint3\" type=\"fixed\"> <origin xyz=\"6E-05 0.0034 0.0001\" rpy=\"1.5708 -0.054172 0\" /> <parent link=\"eje\" /> <child link=\"plumilla\" /> <axis xyz=\"0 0 0\" /> </joint> </robot>","title":"5. URDF"},{"location":"4-1-URDF/#5-urdf","text":"Un archivo URDF es un archivo xacro que describe un componente de un robot, ya sea su descripci\u00f3n puramente f\u00edsica, inercial, de controladores, etc. El que toma m\u00e1s tiempo siempre es el URDF general del robot porque describe toda la configuraci\u00f3n y topolog\u00eda del mismo, para obtener este archivo se pueden tomar dos alternativas: 1. Crear URDF con figuras b\u00e1sicas como cubos y cilindros, este m\u00e9todo suele ser \u00f3ptimo para robots sencillos como un servomotor. 2. Extraer URDF de un software de modelaci\u00f3n como _SolidWorks_, para esto se debe tener el ensamble total de la m\u00e1quina/robot que se desea controlar, este m\u00e9todo es \u00f3ptimo para robots m\u00e1s complejos. En este caso se mostrar\u00e1n brevemente los pasos que se llevaron en el canal de referencia para hacer el URDF del robot diferencial con figuras geom\u00e9tricas y un ejemplo en solidworks con un servomotor extra\u00eddo de _Grabcad_.","title":"5. URDF"},{"location":"4-1-URDF/#51-setup","text":"Para crear el archivo URDF, debe cumplir los siguientes pasos: Tener ROS2 instalado Tener creado un workspace Tener copiada la plantilla de Github Instalar xacro: sudo apt install ros-humble-xacro Instalar joint state publisher: sudo apt install ros-humble-joint-state-publisher-gui Los archivos de configuraci\u00f3n de un robot se escriben en _xacro_, estos archivos son conocidos como archivos de descripci\u00f3n del robot, los documentos se procesan mediante _xacro_ obteniendo un solo archivo URDF que llega a un nodo llamado _robot state publisher_, este nodo convierte los archivos en un _/robotdescription_ y genera todas las transformaciones de las juntas (joints) mediante _/tf_. Con esto, si deseamos mover las articulaciones del robot podemos utilizar _joint state publisher gui_ para visualizar el funcionamiento del robot.","title":"5.1. Setup"},{"location":"4-1-URDF/#52-ejemplo-urdf-con-robot-diferencial","text":"Un robot diferencial es un robot que principalmente est\u00e1 formado por dos ruedas conocidas como _driven wheels_ (una en cada lado), estas dos ruedas son responables de _TODO_ el movimiento del robot; por lo que, todas las dem\u00e1s solamente son para _mantener estable_ el robot conocidas como _caster wheels_. Con esta imagen se puede decir que el robot en realidad puede llegar a ser una _caja_ que tiene a sus lados un par de ruedas de direcci\u00f3n junto con otra rueda de estabilizaci\u00f3n. Para el comienzo del desarrollo del robot se plantean dos cosas: El enlace ra\u00edz (Root link) debe llamarse base link La orientaci\u00f3n de las uniones debe ser: +x delante, +y izquierda, +z arriba","title":"5.2. Ejemplo URDF con Robot diferencial"},{"location":"4-1-URDF/#521-creando-un-archivo-urdf","text":"En la plantilla clonada anteriormente se tiene el siguiente archivo inicial de URDF: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <!-- Example link --> <link name=\"base_link\"> Con este URDF de esta manera al utilizar el comando `ros2 launch my_bot rsp.launch.py` se podr\u00e1 visualizar el \u00fanico link que tiene especificado el URDF. Lo que normalmente se hace es que en un archivo xacro se incluyen dem\u00e1s archivos xacro que contienen distinta informaci\u00f3n como el URDF, el controlador, componentes como c\u00e1mara o dispositivos, etc. Por lo que este archivo base se puede modificar de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"robot\"> <xacro:include filename=\"robot_core.xacro\" /> </robot> Este archivo estar\u00e1 llamando a `robot_core.xacro`, un xacro creado en la misma carpeta que contendr\u00e1 el URDF del robot. Con esto ya se puede crear el archivo URDF del robot, primero se crean los materiales del robot de esta manera: <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> Luego empieza _TODA_ la constituci\u00f3n del robot, esto quiere decir todos los _joints_ y _links_ que este mismo contiene comenzando por el _base link_ y _chassis_: <!-- BASE LINK --> <link name=\"base_link\"> </link> Los joints pueden ser de distintos tipos, tales como: prismatic, revolute, fixed, continuous, etc ; adem\u00e1s, se definen con un parent , child y origin : <!-- CHASSIS LINK --> <joint name=\"chassis_joint\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"chassis\"/> <origin xyz=\"-0.1 0 0\"/> </joint> Luego de definir el joint se procede a definir el link del robot en el que primero se define el _visual_ como una caja de 300x300x150mm (todos los par\u00e1metros de ROS se encuentran siempre en sistema m\u00e9trico internacional) con su respectivo origen y material previamente definido. Luego, se define la _collision_ , que basicamente es el mismo contenido del _visual_ sin el _material_; por \u00faltimo, se define su inercia, en este caso se est\u00e1 incluyendo otro archivo xacro en donde se define una macro llamada `inertial_box`, esta macro se define en otro archivo que se llamar\u00e1 `inertial_macros.xacro` y se incluir\u00e1 de igual manera que se incluy\u00f3 el `robot_core.xacro` <!-- ESTO IR\u00cdA AL INICIO DEL C\u00d3DIGO URDF --> <xacro:include filename=\"inertial_macros.xacro\"/> <!-- Archivo de inertial_macros --> <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> <link name=\"chassis\"> <visual> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> <material name=\"white\"/> </visual> <collision> <origin xyz=\"0.15 0 0.075\"/> <geometry> <box size=\"0.3 0.3 0.15\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.5\" x=\"0.3\" y=\"0.3\" z=\"0.15\"> <origin xyz=\"0.15 0 0.075\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> De esta manera se sigue con las dos ruedas del robot, solamente que los joints ser\u00e1n de tipo _continuous_ y en vez de utilizar una geometr\u00eda de _box_ se utilizar\u00e1 un _cylinder_ (adem\u00e1s de definir origines e inercias). <!-- LEFT WHEEL LINK --> <joint name=\"left_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"left_wheel\"/> <origin xyz=\"0 0.175 0\" rpy=\"-${pi/2} 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"left_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> <!-- RIGHT WHEEL LINK --> <joint name=\"right_wheel_joint\" type=\"continuous\"> <parent link=\"base_link\"/> <child link=\"right_wheel\"/> <origin xyz=\"0 -0.175 0\" rpy=\"${pi/2} 0 0\" /> <axis xyz=\"0 0 -1\"/> </joint> <link name=\"right_wheel\"> <visual> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> <material name=\"blue\"/> </visual> <collision> <geometry> <cylinder radius=\"0.05\" length=\"0.04\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.1\" length=\"0.04\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> Luego de misma manera con la caster wheel con un joint tipo fixed y una geometr\u00eda de sphere : <!-- CASTER WHEEL LINK --> <joint name=\"caster_wheel_joint\" type=\"fixed\"> <parent link=\"chassis\"/> <child link=\"caster_wheel\"/> <origin xyz=\"0.24 0 0\"/> </joint> <link name=\"caster_wheel\"> <visual> <geometry> <sphere radius=\"0.05\"/> </geometry> <material name=\"black\"/> </visual> <collision> <geometry> <sphere radius=\"0.05\"/> </geometry> </collision> <xacro:inertial_sphere mass=\"0.1\" radius=\"0.05\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_sphere> </link> </robot> Con todo esto ya creado ya se podr\u00eda visualizar el robot sin ning\u00fan problema, solo har\u00eda falta compilar colcon build --symlink-install y source install/setup.bash . Despu\u00e9s de esto al correr el comando ros2 launch my_bot rsp.launch.py y en una terminal nueva ros2 run joint_state_publisher_gui joint_state_publisher_gui se podr\u00eda visualizar el robot y mover las ruedas seg\u00fan la definici\u00f3n del URDF.","title":"5.2.1. Creando un archivo URDF"},{"location":"4-1-URDF/#53-ejemplo-servomotor-urdf-con-plugin-de-solidworks","text":"Un servomotor SG90 es un tipo de motor el\u00e9ctrico que se utiliza para controlar la posici\u00f3n, velocidad y aceleraci\u00f3n con precisi\u00f3n; este elemento al tener 1 DOF permite conocer e identificar los pasos a realizar para controlar el robot SCARA al tener una estructura muy similar. Para realizar una simulaci\u00f3n del elemento en movimiento se requiere de un URDF y si se tiene el elemento modelado, SolidWorks posee un plugin que brinda un archivo URDF. PASOS Instalar sw2urdfSETUP.exe para la versi\u00f3n de SolidWorks que se tenga instalado. Instalar plugin de SolidWorks Abrir la pieza en SolidWorks. En la parte superior derecha de la pantalla, se busca la extensi\u00f3n. Se definen las barras o eslabones que presenta el elemento, en este caso, se fja la base como la barra de tierra (inmovil), y se definen los eslabones y pares cinem\u00e1ticos como las partes moviles. Se presiona la opci\u00f3n de \"Preview and export URDF\" y se definen las variablees que posee el elemento, luego se genera el URDF y las mallas del elemento. EJEMPLO DEL URDF EXPORTADO <?xml version=\"1.0\"?> <robot name=\"servo7\"> <link name=\"base\"> <inertial> <origin xyz=\"-6.7573E-06 0.011598 5.6311E-08\" rpy=\"6 0 0\" /> <mass value=\"0.0064019\" /> <inertia ixx=\"3.4577E-07\" ixy=\"-2.7463E-10\" ixz=\"4.3013E-12\" iyy=\"3.8183E-07\" iyz=\"2.2886E-12\" izz=\"5.7895E-07\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/base.STL\" /> </geometry> </collision> </link> <link name=\"plu_chasis\"> <inertial> <origin xyz=\"0.001818 -5.3648E-05 -0.0015\" rpy=\"0 0 0\" /> <mass value=\"0.00035175\" /> <inertia ixx=\"3.232E-09\" ixy=\"1.5994E-25\" ixz=\"1.252E-25\" iyy=\"7.3777E-09\" iyz=\"-1.8232E-25\" izz=\"1.0082E-08\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> <material name=\"\"> <color rgba=\"0.0 0.0 1.0 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plu_chasis.STL\" /> </geometry> </collision> </link> <joint name=\"joint1\" type=\"fixed\"> <origin xyz=\"-0.00409 0.0227 0\" rpy=\"1.5708 -0.007929 0\" /> <parent link=\"base\" /> <child link=\"plu_chasis\" /> <axis xyz=\"0 0 0\" /> </joint> <link name=\"eje\"> <inertial> <origin xyz=\"6.3741E-05 0.0031 4.638E-05\" rpy=\"0 0 0\" /> <mass value=\"0.00010538\" /> <inertia ixx=\"6.1365E-10\" ixy=\"-1.9311E-27\" ixz=\"-2.6707E-26\" iyy=\"3.168E-10\" iyz=\"-1.2874E-27\" izz=\"6.1365E-10\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"0.5 0.5 0.5 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/eje.STL\" /> </geometry> </collision> </link> <joint name=\"joint2\" type=\"continuous\"> <origin xyz=\"-0.00415 0.0232 -0.0001\" rpy=\"0 0 0\" /> <parent link=\"base\" /> <child link=\"eje\" /> <axis xyz=\"0 1 0\" /> <dynamics friction=\"0.1\" /> </joint> <link name=\"plumilla\"> <inertial> <origin xyz=\"0.0042098 5.9689E-05 -0.0021514\" rpy=\"0 0 0\" /> <mass value=\"0.00011261\" /> <inertia ixx=\"4.3387E-10\" ixy=\"-6.7617E-11\" ixz=\"2.3634E-10\" iyy=\"2.941E-09\" iyz=\"6.3694E-12\" izz=\"3.2007E-09\" /> </inertial> <visual> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> <material name=\"acrylic\"> <color rgba=\"1.0 0.41 0.71 1.0\" /> </material> </visual> <collision> <origin xyz=\"0 0 0\" rpy=\"0 0 0\" /> <geometry> <mesh filename=\"package://modelo_servo/meshes/plumilla.STL\" /> </geometry> </collision> </link> <joint name=\"joint3\" type=\"fixed\"> <origin xyz=\"6E-05 0.0034 0.0001\" rpy=\"1.5708 -0.054172 0\" /> <parent link=\"eje\" /> <child link=\"plumilla\" /> <axis xyz=\"0 0 0\" /> </joint> </robot>","title":"5.3. Ejemplo Servomotor URDF con Plugin de SolidWorks"},{"location":"5-0-Servo/","text":"6. Servo Con los pasos requeridos para ejecutar el robot diferencial, se procedi\u00f3 a realizar el mismo proceso para un servomotor. Para esto, como bien se menciona anteriormente, se pueden utilizar dos m\u00e9todos: Constituir el servo con figuras volum\u00e9tricas b\u00e1sicas Extraer el URDF con el plugin de solidworks como se mostr\u00f3 en el ejemplo anterior. Un servomotor es un dispositivo que permite controlar con m\u00e1xima precisi\u00f3n la posici\u00f3n y movimiento de su eje. Esto quiere decir que se puede mover en un \u00e1ngulo, posici\u00f3n y a una velocidad determinada en cada momento, cosa que no puede hacer con normalidad un motor el\u00e9ctrico. Industrialmente, se utilizan los servos en todas aquellas aplicaciones de automatizaci\u00f3n industrial y rob\u00f3tica en las que se necesitan un exhaustivo control del par, del posicionamiento y de la velocidad para mejorar la calidad y la productividad. Los servomotores pueden ser industriales o de electr\u00f3nica b\u00e1sica, su principal diferencia son los l\u00edmites de rotaci\u00f3n que pueden llegar a tener, un servo industrial puede tener un giro de 360 grados sin problema, mientras un servo de electr\u00f3nica b\u00e1sica solamente tiene libertad de 180 grados. En este caso se estar\u00e1 trabajando con un servo de electr\u00f3nica b\u00e1sica como el siguiente: En terminos de mecanismos internos, un servo es un dispositivo que se puede modelar muy f\u00e1cilmente, solo contiene un chasis que ser\u00eda la caja azul y tendr\u00eda la parte superior que rota sobre un eje que se denomina como plumilla . Ante esta situaci\u00f3n, se decidi\u00f3 realizar toda la aplicaci\u00f3n del servo con figuras volum\u00e9tricas b\u00e1sicas, toda esta configuraci\u00f3n se encuentra en el siguiente enlace . En las siguientes p\u00e1ginas se explicar\u00e1 brevemente los pasos para controlar un servomotor que posee 1 DOF y el contenido del repositorio que contiene los c\u00f3digos utilizados en la soluci\u00f3n del problema. Se controla primeramente un servomotor con la intenci\u00f3n de entender c\u00f3mo funciona rob\u00f3ticamente ROS 2 y c\u00f3mo se controla cada grado de libertad, posteriormente se implementar\u00e1 lo aprendido para controlar el robot SCARA.","title":"6. Servo"},{"location":"5-0-Servo/#6-servo","text":"Con los pasos requeridos para ejecutar el robot diferencial, se procedi\u00f3 a realizar el mismo proceso para un servomotor. Para esto, como bien se menciona anteriormente, se pueden utilizar dos m\u00e9todos: Constituir el servo con figuras volum\u00e9tricas b\u00e1sicas Extraer el URDF con el plugin de solidworks como se mostr\u00f3 en el ejemplo anterior. Un servomotor es un dispositivo que permite controlar con m\u00e1xima precisi\u00f3n la posici\u00f3n y movimiento de su eje. Esto quiere decir que se puede mover en un \u00e1ngulo, posici\u00f3n y a una velocidad determinada en cada momento, cosa que no puede hacer con normalidad un motor el\u00e9ctrico. Industrialmente, se utilizan los servos en todas aquellas aplicaciones de automatizaci\u00f3n industrial y rob\u00f3tica en las que se necesitan un exhaustivo control del par, del posicionamiento y de la velocidad para mejorar la calidad y la productividad. Los servomotores pueden ser industriales o de electr\u00f3nica b\u00e1sica, su principal diferencia son los l\u00edmites de rotaci\u00f3n que pueden llegar a tener, un servo industrial puede tener un giro de 360 grados sin problema, mientras un servo de electr\u00f3nica b\u00e1sica solamente tiene libertad de 180 grados. En este caso se estar\u00e1 trabajando con un servo de electr\u00f3nica b\u00e1sica como el siguiente: En terminos de mecanismos internos, un servo es un dispositivo que se puede modelar muy f\u00e1cilmente, solo contiene un chasis que ser\u00eda la caja azul y tendr\u00eda la parte superior que rota sobre un eje que se denomina como plumilla . Ante esta situaci\u00f3n, se decidi\u00f3 realizar toda la aplicaci\u00f3n del servo con figuras volum\u00e9tricas b\u00e1sicas, toda esta configuraci\u00f3n se encuentra en el siguiente enlace . En las siguientes p\u00e1ginas se explicar\u00e1 brevemente los pasos para controlar un servomotor que posee 1 DOF y el contenido del repositorio que contiene los c\u00f3digos utilizados en la soluci\u00f3n del problema. Se controla primeramente un servomotor con la intenci\u00f3n de entender c\u00f3mo funciona rob\u00f3ticamente ROS 2 y c\u00f3mo se controla cada grado de libertad, posteriormente se implementar\u00e1 lo aprendido para controlar el robot SCARA.","title":"6. Servo"},{"location":"5-1-ServoXacros/","text":"7. Servo Xacros En el repositorio previamente expuesto se encuentran distintos archivos xacro. A continuaci\u00f3n, se enlistan los archivos con una peque\u00f1a descripci\u00f3n de los mismos. Adem\u00e1s, se mencionan las principales caracter\u00edsticas de cada uno: Gazebo: Descripci\u00f3n de robot en materiales (colores) y en hardware component con toda la integraci\u00f3n de ros2 control, en esta parte se describe el plugin necesario y los joints del robot con sus command interfaces y state interfaces . Ros2 control: Descripci\u00f3n de robot para aplicaci\u00f3n en servo REAL , para esto se utiliza como plugin los archivos de servo Hardware y par\u00e1metros importantes para el control como el Baud rate , constantes PID , Serial Device , entre otros. URDF: Descripci\u00f3n general del robot, al haber sido realizada con geometr\u00edas b\u00e1sicas tambi\u00e9n se encuentran archivos como Inertial macros y Servo materials ; adem\u00e1s, al ser un repositorio que cuenta con la opci\u00f3n de simular el servo en Gazebo y luego realizar la aplcaci\u00f3n con el servo real, se encuentran dos archivos para cada una de estas: servo.simulated.xacro y servo.urdf.xacro respectivamente. 7.1. Gazebo xacro Un concepto clave para los archivos xacros que se debe tener en claro es la diferenciaci\u00f3n entre `command interfaces` y `state interfaces`. Las `command interfaces` se utilizan como recurso para enviar _comandos_ deseados para controlar el robot/dispositivo; mientras que, las `state interfaces`se usan para saber los _estados_ actuales de par\u00e1metros del robot. Por ejemplo en el servo se tiene como `command interface` la posici\u00f3n del servo, porque se desea mover el servo ingres\u00e1ndole _comandos_ de posici\u00f3n; mientras que, para `state interfaces` se tiene la posici\u00f3n y velocidad del servo. La selecci\u00f3n de estos par\u00e1metros depender\u00e1 siempre del controlador Enlace del controlador Hablando un poco del archivo xacro, se tiene al inicio la descripci\u00f3n de los colores del robot <?xml version=\"1.0\"?> <robot> <!-- Gazebo Colors --> <gazebo reference=\"motor\"> <material>Gazebo/Blue</material> </gazebo> <gazebo reference=\"arm\"> <material>Gazebo/White</material> </gazebo> Despu\u00e9s de esto se tiene la integraci\u00f3n con el hardware component, en donde se utiliza como plugin la opci\u00f3n de _GazeboSystem_ al ser el xacro el servo simulado, despu\u00e9s se describen los joints con los l\u00edmites y las `command interfaces` y `state interfaces`. <!-- Gazebo Hardware Component --> <ros2_control name=\"GazeboSystem\" type=\"system\"> <hardware> <plugin>gazebo_ros2_control/GazeboSystem</plugin> </hardware> <joint name=\"servo_joint\"> <command_interface name=\"position\"> <param name=\"min\">-1.58</param> <param name=\"max\">1.58</param> </command_interface> <state_interface name=\"position\"> <param name=\"initial_value\">0</param> </state_interface> <state_interface name=\"velocity\"/> <state_interface name=\"effort\"/> </joint> </ros2_control> Por \u00faltimo, se tienen unas lineas en donde se ingresa la ruta para encontrar el controlador del robot, este archivo es un script .YAML y se describir\u00e1 m\u00e1s adelante. <gazebo> <plugin filename=\"libgazebo_ros2_control.so\" name=\"gazebo_ros2_control\"> <parameters>$(find servo_hardware)/config/servo_controllers_gazebo.yaml</parameters> </plugin> </gazebo> </robot> 7.2. ROS2 Control El xacro del ros2 Control se utiliza cuando se desea controlar el servo REAL conectado al PC, para esto se necesiten los archivos en C++ que se describir\u00e1n m\u00e1s adelante. Adem\u00e1s de eso, se ingresan par\u00e1metros necesarios para el control del dispoitivo. <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"> <xacro:macro name=\"servo_ros2_control\" params=\"name prefix\"> <ros2_control name=\"${name}\" type=\"system\"> <hardware> <plugin>servo_hardware/ServoArduinoHardware</plugin> <param name=\"joint1_name\">servo_joint</param> <param name=\"loop_rate\">30</param> <param name=\"device\">/home/jammy/servo</param> <param name=\"baud_rate\">115200</param> <param name=\"timeout_ms\">1000</param> <param name=\"enc_counts_per_rev\">3436</param> <param name=\"pid_p\">20</param> <param name=\"pid_d\">12</param> <param name=\"pid_i\">0</param> <param name=\"pid_o\">50</param> </hardware> <joint name=\"${prefix}servo_joint\"> <command_interface name=\"position\"/> <state_interface name=\"position\"/> <state_interface name=\"velocity\"/> </joint> </ros2_control> </xacro:macro> </robot> 7.3. URDF Como se menciona anteriormente, el URDF de este robot contiene distintos archivos xacro como las Inertial macros y Servo materials 7.3.1. Inertial Macros y Servo materials Estos archivos son bastante similares a los vistos en el ejemplo del robot diferencial, las Inertial macros siempre depender\u00e1n de la complejidad geom\u00e9trica del robot: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> Como se puede observar, es literalmente la misma macro empleada en el robot diferencial al utilizarse las mismas figur\u00e1s volum\u00e9tricas. Para la parte de los materiales del robot, tambi\u00e9n se realizaron de manera equivalente como en el robot diferencial: <?xml version=\"1.0\"?> <!-- Copied from ROS1 example: https://github.com/ros-simulation/gazebo_ros_demos/blob/kinetic-devel/rrbot_description/urdf/materials.xacro --> <robot> <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> </robot> 7.3.2. Servo description En el xacro de servo description se tiene TODO el URDF del servo empleado en el repositorio. Para esto primero se incluyen las macros previamente expuestas: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <xacro:include filename=\"$(find servo_hardware)/urdf/inertial_macros.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.materials.xacro\" /> Luego se empieza con la definici\u00f3n de los links y joints primero con el MOTOR o CHASIS del servo. <!-- BASE LINK --> <link name=\"base_link\" /> <joint name=\"fixation\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"motor\"/> <origin xyz=\"0 0 0.267\"/> </joint> <!-- MOTOR LINK --> <link name=\"motor\"> <visual> <origin xyz=\"0.0 0.0535 -0.1535\"/> <geometry> <box size=\"0.118 0.225 0.227\"/> </geometry> <material name=\"blue\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.025\"/> <geometry> <cylinder radius=\"0.059\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.063 -0.025\"/> <geometry> <cylinder radius=\"0.025\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.0535 -0.0955\"/> <geometry> <box size=\"0.118 0.319 0.025\"/> </geometry> </visual> <collision> <origin xyz=\"0.0 0.0535 -0.1335\"/> <geometry> <box size=\"0.118 0.319 0.267\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.15\" x=\"0.118\" y=\"0.319\" z=\"0.267\"> <origin xyz=\"0.0 0.0535 -0.1335\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> Y luego con el ARM del servo o PLUMILLA <!-- ARM LINK --> <joint name=\"servo_joint\" type=\"revolute\"> <limit lower=\"-${pi/2}\" upper=\"${pi/2}\" effort=\"0.0\" velocity=\"0.0\"/> <parent link=\"motor\"/> <child link=\"arm\"/> <origin xyz=\"0 0 0.042\" rpy=\"0 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"arm\"> <visual> <origin xyz=\"0.0 0.0 -0.027\"/> <geometry> <cylinder radius=\"0.023\" length=\"0.03\"/> </geometry> <material name=\"white\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.021\"/> <geometry> <cylinder radius=\"0.05\" length=\"0.054\"/> </geometry> </visual> <visual> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.254 0.08 0.02\"/> </geometry> </visual> <collision> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.304 0.08 0.02\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.023\" radius=\"0.05\" length=\"0.03\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> </robot> 7.4. Servo simulated y servo urdf Por \u00faltimo, se tienen dos xacros para las dos aplicaciones previamente mencionadas del robot 7.4.1. Servo simulated Este xacro se emplea \u00fanicamente para simular el servo en Gazebo , por lo que, en este archivo se incluyen los archivos necesarios para la simulaci\u00f3n; es decir, servo.description.xacro y servo.gazebo.xacro <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/gazebo/servo.gazebo.xacro\" /> </robot> 7.4.2. Servo urdf Y por otro lado, el servo.urdf.xacro incluye los archivos necesarios para realizar al aplicaci\u00f3n con el servo real ( servo.description.xacro y servo.ros2_control.xacro ) <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/ros2_control/servo.ros2_control.xacro\" /> <xacro:servo_ros2_control name=\"servo\" prefix=\"\" /> </robot>","title":"7. Servo Xacros"},{"location":"5-1-ServoXacros/#7-servo-xacros","text":"En el repositorio previamente expuesto se encuentran distintos archivos xacro. A continuaci\u00f3n, se enlistan los archivos con una peque\u00f1a descripci\u00f3n de los mismos. Adem\u00e1s, se mencionan las principales caracter\u00edsticas de cada uno: Gazebo: Descripci\u00f3n de robot en materiales (colores) y en hardware component con toda la integraci\u00f3n de ros2 control, en esta parte se describe el plugin necesario y los joints del robot con sus command interfaces y state interfaces . Ros2 control: Descripci\u00f3n de robot para aplicaci\u00f3n en servo REAL , para esto se utiliza como plugin los archivos de servo Hardware y par\u00e1metros importantes para el control como el Baud rate , constantes PID , Serial Device , entre otros. URDF: Descripci\u00f3n general del robot, al haber sido realizada con geometr\u00edas b\u00e1sicas tambi\u00e9n se encuentran archivos como Inertial macros y Servo materials ; adem\u00e1s, al ser un repositorio que cuenta con la opci\u00f3n de simular el servo en Gazebo y luego realizar la aplcaci\u00f3n con el servo real, se encuentran dos archivos para cada una de estas: servo.simulated.xacro y servo.urdf.xacro respectivamente.","title":"7. Servo Xacros"},{"location":"5-1-ServoXacros/#71-gazebo-xacro","text":"Un concepto clave para los archivos xacros que se debe tener en claro es la diferenciaci\u00f3n entre `command interfaces` y `state interfaces`. Las `command interfaces` se utilizan como recurso para enviar _comandos_ deseados para controlar el robot/dispositivo; mientras que, las `state interfaces`se usan para saber los _estados_ actuales de par\u00e1metros del robot. Por ejemplo en el servo se tiene como `command interface` la posici\u00f3n del servo, porque se desea mover el servo ingres\u00e1ndole _comandos_ de posici\u00f3n; mientras que, para `state interfaces` se tiene la posici\u00f3n y velocidad del servo. La selecci\u00f3n de estos par\u00e1metros depender\u00e1 siempre del controlador Enlace del controlador Hablando un poco del archivo xacro, se tiene al inicio la descripci\u00f3n de los colores del robot <?xml version=\"1.0\"?> <robot> <!-- Gazebo Colors --> <gazebo reference=\"motor\"> <material>Gazebo/Blue</material> </gazebo> <gazebo reference=\"arm\"> <material>Gazebo/White</material> </gazebo> Despu\u00e9s de esto se tiene la integraci\u00f3n con el hardware component, en donde se utiliza como plugin la opci\u00f3n de _GazeboSystem_ al ser el xacro el servo simulado, despu\u00e9s se describen los joints con los l\u00edmites y las `command interfaces` y `state interfaces`. <!-- Gazebo Hardware Component --> <ros2_control name=\"GazeboSystem\" type=\"system\"> <hardware> <plugin>gazebo_ros2_control/GazeboSystem</plugin> </hardware> <joint name=\"servo_joint\"> <command_interface name=\"position\"> <param name=\"min\">-1.58</param> <param name=\"max\">1.58</param> </command_interface> <state_interface name=\"position\"> <param name=\"initial_value\">0</param> </state_interface> <state_interface name=\"velocity\"/> <state_interface name=\"effort\"/> </joint> </ros2_control> Por \u00faltimo, se tienen unas lineas en donde se ingresa la ruta para encontrar el controlador del robot, este archivo es un script .YAML y se describir\u00e1 m\u00e1s adelante. <gazebo> <plugin filename=\"libgazebo_ros2_control.so\" name=\"gazebo_ros2_control\"> <parameters>$(find servo_hardware)/config/servo_controllers_gazebo.yaml</parameters> </plugin> </gazebo> </robot>","title":"7.1. Gazebo xacro"},{"location":"5-1-ServoXacros/#72-ros2-control","text":"El xacro del ros2 Control se utiliza cuando se desea controlar el servo REAL conectado al PC, para esto se necesiten los archivos en C++ que se describir\u00e1n m\u00e1s adelante. Adem\u00e1s de eso, se ingresan par\u00e1metros necesarios para el control del dispoitivo. <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"> <xacro:macro name=\"servo_ros2_control\" params=\"name prefix\"> <ros2_control name=\"${name}\" type=\"system\"> <hardware> <plugin>servo_hardware/ServoArduinoHardware</plugin> <param name=\"joint1_name\">servo_joint</param> <param name=\"loop_rate\">30</param> <param name=\"device\">/home/jammy/servo</param> <param name=\"baud_rate\">115200</param> <param name=\"timeout_ms\">1000</param> <param name=\"enc_counts_per_rev\">3436</param> <param name=\"pid_p\">20</param> <param name=\"pid_d\">12</param> <param name=\"pid_i\">0</param> <param name=\"pid_o\">50</param> </hardware> <joint name=\"${prefix}servo_joint\"> <command_interface name=\"position\"/> <state_interface name=\"position\"/> <state_interface name=\"velocity\"/> </joint> </ros2_control> </xacro:macro> </robot>","title":"7.2. ROS2 Control"},{"location":"5-1-ServoXacros/#73-urdf","text":"Como se menciona anteriormente, el URDF de este robot contiene distintos archivos xacro como las Inertial macros y Servo materials","title":"7.3. URDF"},{"location":"5-1-ServoXacros/#731-inertial-macros-y-servo-materials","text":"Estos archivos son bastante similares a los vistos en el ejemplo del robot diferencial, las Inertial macros siempre depender\u00e1n de la complejidad geom\u00e9trica del robot: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <!-- Specify some standard inertial calculations https://en.wikipedia.org/wiki/List_of_moments_of_inertia --> <!-- These make use of xacro's mathematical functionality --> <xacro:macro name=\"inertial_sphere\" params=\"mass radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(2/5) * mass * (radius*radius)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(2/5) * mass * (radius*radius)}\" iyz=\"0.0\" izz=\"${(2/5) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_box\" params=\"mass x y z *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (y*y+z*z)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (x*x+z*z)}\" iyz=\"0.0\" izz=\"${(1/12) * mass * (x*x+y*y)}\" /> </inertial> </xacro:macro> <xacro:macro name=\"inertial_cylinder\" params=\"mass length radius *origin\"> <inertial> <xacro:insert_block name=\"origin\"/> <mass value=\"${mass}\" /> <inertia ixx=\"${(1/12) * mass * (3*radius*radius + length*length)}\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"${(1/12) * mass * (3*radius*radius + length*length)}\" iyz=\"0.0\" izz=\"${(1/2) * mass * (radius*radius)}\" /> </inertial> </xacro:macro> </robot> Como se puede observar, es literalmente la misma macro empleada en el robot diferencial al utilizarse las mismas figur\u00e1s volum\u00e9tricas. Para la parte de los materiales del robot, tambi\u00e9n se realizaron de manera equivalente como en el robot diferencial: <?xml version=\"1.0\"?> <!-- Copied from ROS1 example: https://github.com/ros-simulation/gazebo_ros_demos/blob/kinetic-devel/rrbot_description/urdf/materials.xacro --> <robot> <material name=\"white\"> <color rgba=\"1 1 1 1\" /> </material> <material name=\"orange\"> <color rgba=\"1 0.3 0.1 1\"/> </material> <material name=\"blue\"> <color rgba=\"0.2 0.2 1 1\"/> </material> <material name=\"black\"> <color rgba=\"0 0 0 1\"/> </material> </robot>","title":"7.3.1. Inertial Macros y Servo materials"},{"location":"5-1-ServoXacros/#732-servo-description","text":"En el xacro de servo description se tiene TODO el URDF del servo empleado en el repositorio. Para esto primero se incluyen las macros previamente expuestas: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" > <xacro:include filename=\"$(find servo_hardware)/urdf/inertial_macros.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.materials.xacro\" /> Luego se empieza con la definici\u00f3n de los links y joints primero con el MOTOR o CHASIS del servo. <!-- BASE LINK --> <link name=\"base_link\" /> <joint name=\"fixation\" type=\"fixed\"> <parent link=\"base_link\"/> <child link=\"motor\"/> <origin xyz=\"0 0 0.267\"/> </joint> <!-- MOTOR LINK --> <link name=\"motor\"> <visual> <origin xyz=\"0.0 0.0535 -0.1535\"/> <geometry> <box size=\"0.118 0.225 0.227\"/> </geometry> <material name=\"blue\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.025\"/> <geometry> <cylinder radius=\"0.059\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.063 -0.025\"/> <geometry> <cylinder radius=\"0.025\" length=\"0.05\"/> </geometry> </visual> <visual> <origin xyz=\"0.0 0.0535 -0.0955\"/> <geometry> <box size=\"0.118 0.319 0.025\"/> </geometry> </visual> <collision> <origin xyz=\"0.0 0.0535 -0.1335\"/> <geometry> <box size=\"0.118 0.319 0.267\"/> </geometry> </collision> <xacro:inertial_box mass=\"0.15\" x=\"0.118\" y=\"0.319\" z=\"0.267\"> <origin xyz=\"0.0 0.0535 -0.1335\" rpy=\"0 0 0\"/> </xacro:inertial_box> </link> Y luego con el ARM del servo o PLUMILLA <!-- ARM LINK --> <joint name=\"servo_joint\" type=\"revolute\"> <limit lower=\"-${pi/2}\" upper=\"${pi/2}\" effort=\"0.0\" velocity=\"0.0\"/> <parent link=\"motor\"/> <child link=\"arm\"/> <origin xyz=\"0 0 0.042\" rpy=\"0 0 0\" /> <axis xyz=\"0 0 1\"/> </joint> <link name=\"arm\"> <visual> <origin xyz=\"0.0 0.0 -0.027\"/> <geometry> <cylinder radius=\"0.023\" length=\"0.03\"/> </geometry> <material name=\"white\"/> </visual> <visual> <origin xyz=\"0.0 0.0 -0.021\"/> <geometry> <cylinder radius=\"0.05\" length=\"0.054\"/> </geometry> </visual> <visual> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.254 0.08 0.02\"/> </geometry> </visual> <collision> <origin xyz=\"0.127 0.0 -0.01\"/> <geometry> <box size=\"0.304 0.08 0.02\"/> </geometry> </collision> <xacro:inertial_cylinder mass=\"0.023\" radius=\"0.05\" length=\"0.03\"> <origin xyz=\"0 0 0\" rpy=\"0 0 0\"/> </xacro:inertial_cylinder> </link> </robot>","title":"7.3.2. Servo description"},{"location":"5-1-ServoXacros/#74-servo-simulated-y-servo-urdf","text":"Por \u00faltimo, se tienen dos xacros para las dos aplicaciones previamente mencionadas del robot","title":"7.4. Servo simulated y servo urdf"},{"location":"5-1-ServoXacros/#741-servo-simulated","text":"Este xacro se emplea \u00fanicamente para simular el servo en Gazebo , por lo que, en este archivo se incluyen los archivos necesarios para la simulaci\u00f3n; es decir, servo.description.xacro y servo.gazebo.xacro <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/gazebo/servo.gazebo.xacro\" /> </robot>","title":"7.4.1. Servo simulated"},{"location":"5-1-ServoXacros/#742-servo-urdf","text":"Y por otro lado, el servo.urdf.xacro incluye los archivos necesarios para realizar al aplicaci\u00f3n con el servo real ( servo.description.xacro y servo.ros2_control.xacro ) <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <xacro:include filename=\"$(find servo_hardware)/ros2_control/servo.ros2_control.xacro\" /> <xacro:servo_ros2_control name=\"servo\" prefix=\"\" /> </robot>","title":"7.4.2. Servo urdf"},{"location":"5-2-ServoControllers/","text":"8. Servo Controllers Los controladores son la parte m\u00e1s esencial de todo el proceso de simulaci\u00f3n y por supuesto, de control. Para toda la simulaci\u00f3n se emplean distintos archivos de controladores, los cuales se expresan en .yaml . Para la simulaci\u00f3n solamente se necesiten dos archivos de controladores: ros2_controllers.yaml ubicado en la carpeta config del paquete servo_hardware moveit_controllers.yaml ubicado en la carpeta config del paquete servo_hardware_moveit_config Como se pudo visualizar en los archivos xacro , los controladores se ingresan mediante un archivo de este tipo y depender\u00e1 de la simulaci\u00f3n que se desee realizar. Adem\u00e1s de esto, para la selecci\u00f3n del controlador se deben tener en cuenta varios detalles: command interfaces del robot state interfaces del robot Controladores a disposici\u00f3n para adaptar ( Repositorio ) 8.1 Estructura de archivo Los archivos de controlares est\u00e1n compuestos por dos partes: Declaraci\u00f3n de controlares y Descripci\u00f3n de controladores Declaraci\u00f3n de controladores Para el caso del servo se utilizaron los controladores: Joint trajectory controller y Joint state broadcaster , el primero de estos sirve para darle una trayectoria de puntos al controlador y est\u00e9 lo utilizar\u00e1 para mover robot y alcanzar estos puntos. Por otro lado, el Joint state broadcaster se utiliza para poder tener una conexi\u00f3n continua con el estado de los joints del robot, es recomedable utilizarlo siempre en estos casos. controller_manager: ros__parameters: update_rate: 1000 # Hz use_sim_time: true joint_trajectory_controller: type: joint_trajectory_controller/JointTrajectoryController joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster La declaraci\u00f3n como se puede visualizar esta compuesta meramente por el nombramiento de los controlares, utilizando la librer\u00eda y nombre indicado. Descripci\u00f3n de controladores Despu\u00e9s de esto, la descripci\u00f3n se basa en el ingreso de todos los par\u00e1metros que necesita el controlador para funcionar; es decir, se ingresan los joints , command interfaces y state interfaces , claramente si el controlador lo requiere. joint_trajectory_controller: ros__parameters: joints: - servo_joint interface_name: position command_interfaces: - position state_interfaces: - position - velocity allow_nonzero_velocity_at_trajectory_end: false joint_state_broadcaster: ros__parameters: joints: - servo_joint En este caso el Joint trajectory controller requiere el ingreso de todos los par\u00e1metros mencionados, pero por otro lado el Joint state broadcaster solamente necesita los joints .","title":"8. Servo Controllers"},{"location":"5-2-ServoControllers/#8-servo-controllers","text":"Los controladores son la parte m\u00e1s esencial de todo el proceso de simulaci\u00f3n y por supuesto, de control. Para toda la simulaci\u00f3n se emplean distintos archivos de controladores, los cuales se expresan en .yaml . Para la simulaci\u00f3n solamente se necesiten dos archivos de controladores: ros2_controllers.yaml ubicado en la carpeta config del paquete servo_hardware moveit_controllers.yaml ubicado en la carpeta config del paquete servo_hardware_moveit_config Como se pudo visualizar en los archivos xacro , los controladores se ingresan mediante un archivo de este tipo y depender\u00e1 de la simulaci\u00f3n que se desee realizar. Adem\u00e1s de esto, para la selecci\u00f3n del controlador se deben tener en cuenta varios detalles: command interfaces del robot state interfaces del robot Controladores a disposici\u00f3n para adaptar ( Repositorio )","title":"8. Servo Controllers"},{"location":"5-2-ServoControllers/#81-estructura-de-archivo","text":"Los archivos de controlares est\u00e1n compuestos por dos partes: Declaraci\u00f3n de controlares y Descripci\u00f3n de controladores","title":"8.1 Estructura de archivo"},{"location":"5-2-ServoControllers/#declaracion-de-controladores","text":"Para el caso del servo se utilizaron los controladores: Joint trajectory controller y Joint state broadcaster , el primero de estos sirve para darle una trayectoria de puntos al controlador y est\u00e9 lo utilizar\u00e1 para mover robot y alcanzar estos puntos. Por otro lado, el Joint state broadcaster se utiliza para poder tener una conexi\u00f3n continua con el estado de los joints del robot, es recomedable utilizarlo siempre en estos casos. controller_manager: ros__parameters: update_rate: 1000 # Hz use_sim_time: true joint_trajectory_controller: type: joint_trajectory_controller/JointTrajectoryController joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster La declaraci\u00f3n como se puede visualizar esta compuesta meramente por el nombramiento de los controlares, utilizando la librer\u00eda y nombre indicado.","title":"Declaraci\u00f3n de controladores"},{"location":"5-2-ServoControllers/#descripcion-de-controladores","text":"Despu\u00e9s de esto, la descripci\u00f3n se basa en el ingreso de todos los par\u00e1metros que necesita el controlador para funcionar; es decir, se ingresan los joints , command interfaces y state interfaces , claramente si el controlador lo requiere. joint_trajectory_controller: ros__parameters: joints: - servo_joint interface_name: position command_interfaces: - position state_interfaces: - position - velocity allow_nonzero_velocity_at_trajectory_end: false joint_state_broadcaster: ros__parameters: joints: - servo_joint En este caso el Joint trajectory controller requiere el ingreso de todos los par\u00e1metros mencionados, pero por otro lado el Joint state broadcaster solamente necesita los joints .","title":"Descripci\u00f3n de controladores"},{"location":"5-3-ServoMoveIt/","text":"9. Servo Moveit Para utilizar MoveIt se requieren m\u00faltiples archivos para su funcionamiento, estos se enlistan a continuaci\u00f3n: 9.1 Archivos xacro gazebo.xacro mock.xacro servo.urdf servo.srdf Los archivos xacro a excepci\u00f3n del archivo servo.srdf , son los mismos previamente realizados y explicados, por lo que estos 3 archivos se basan simplemente en incluir los dem\u00e1s de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <!-- Import panda urdf file --> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <!-- Import servo ros2_control description --> <xacro:include filename=\"servo.ros2_control.xacro\" /> <xacro:servo_ros2_control name=\"servo\" plugin=\"servo_hardware/ServoArduinoHardware\" prefix=\"\" /> </robot> Este es el c\u00f3digo del archivo servo.urdf en donde meramente se incluye el urdf del servo y se incluye la descripci\u00f3n del hardware del robot. Servo.srdf El \u00fanico archivo que no se hab\u00eda mencionado hasta el momento es el servo.srdf , este archivo es una descripci\u00f3n de la cadena del robot; es decir, c\u00f3mo est\u00e1 conectado el mismo por componentes. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!--This does not replace URDF, and is not an extension of URDF. This is a format for representing semantic information about the robot structure. A URDF file must exist for this robot as well, where the joints and the links that are referenced are defined --> <robot name=\"servo\"> <!--GROUPS: Representation of a set of joints and links. This can be useful for specifying DOF to plan for, defining arms, end effectors, etc--> <!--LINKS: When a link is specified, the parent joint of that link (if it exists) is automatically included--> <!--JOINTS: When a joint is specified, the child link of that joint (which will always exist) is automatically included--> <!--CHAINS: When a chain is specified, all the links along the chain (including endpoints) are included in the group. Additionally, all the joints that are parents to included links are also included. This means that joints along the chain and the parent joint of the base link are included in the group--> <!--SUBGROUPS: Groups can also be formed by referencing to already defined group names--> <group name=\"group_name\"> <link name=\"motor\"/> <link name=\"arm\"/> <joint name=\"servo_joint\"/> <chain base_link=\"motor\" tip_link=\"arm\"/> </group> <!--GROUP STATES: Purpose: Define a named state for a particular group, in terms of joint values. This is useful to define states like 'folded arms'--> <group_state name=\"zero\" group=\"group_name\"> <joint name=\"servo_joint\" value=\"0\"/> </group_state> <group_state name=\"p_one\" group=\"group_name\"> <joint name=\"servo_joint\" value=\"1\"/> </group_state> <group_state name=\"n_one\" group=\"group_name\"> <joint name=\"servo_joint\" value=\"-1\"/> </group_state> <!--VIRTUAL JOINT: Purpose: this element defines a virtual joint between a robot link and an external frame of reference (considered fixed with respect to the robot)--> <virtual_joint name=\"world_joint\" type=\"fixed\" parent_frame=\"world\" child_link=\"base_link\"/> <!--DISABLE COLLISIONS: By default it is assumed that any link of the robot could potentially come into collision with any other link in the robot. This tag disables collision checking between a specified pair of links. --> <disable_collisions link1=\"arm\" link2=\"motor\" reason=\"Adjacent\"/> </robot> Como se puede observar, primero se enlista el grupo o cadena del robot bajo el nombre group name en donde se enlista toda la cadena de joints y links del robot. Luego de esto se definen los group states que son b\u00e1sicamente algunos estados del robot, estas vendr\u00edan siendo unas posiciones determinadas para el movimiento del mismo; y por \u00faltimo se pueden definir dos cosas virtual joint en donde se establece un joint entre el robot y el mundo para que no vuele el robot en la simulaci\u00f3n y disable collisions en donde se definen que joints no pueden chocar por ser adyacentes o simplemente ser imposible su colisi\u00f3n. 9.2 Archivos yaml chomp_planning.yaml ompl_planning.yaml pliz_cartesian_limits.yaml sensors.yaml moveit_controllers.yaml joint_limits.yaml kinematics.yaml Anteriormente, los archivos yaml pod\u00edan ser extra\u00eddos con el moveit assistant en ROS 1 , en el caso del servo y el scara se utilizaron los archivos extra\u00eddos previamente con ROS y se adaptaron a las necesidades propias. En MoveIt un robot se puede mover con diferentes planners , tales como chomp , ompl y pliz , estos se atribuyen a los 3 primeros archivos yaml , cada uno se diferencia en el objetivo que se requiera, por ejemplo para un movimiento con coordenadas vendr\u00eda siendo mejor un pliz ; sin embargo, en el proyecto inicialmente se utiliz\u00f3 el ompl . El archivo de sensors.yaml actualmente se encuentra vac\u00edo teniendo en cuenta que no se tienen sensores integrados al robot, el archivo de moveit_controllers.yaml se integra el controlador default de moveit y el que utilizamos para controlar el servo; es decir, el Joint trajectory controller de la siguiente manera: Moveit controllers # MoveIt uses this configuration for controller management trajectory_execution: allowed_execution_duration_scaling: 1.2 allowed_goal_duration_margin: 0.5 allowed_start_tolerance: 0.01 moveit_controller_manager: moveit_simple_controller_manager/MoveItSimpleControllerManager moveit_simple_controller_manager: controller_names: - servo_controller servo_controller: action_ns: follow_joint_trajectory type: FollowJointTrajectory default: true joints: - servo_joint Por \u00faltimo se tienen los archivos joint_limits.yaml y kinematics.yaml , para joint_limits.yaml se decriben los l\u00edmites de los joints en t\u00e9rminos meramente de velocidad y aceleraci\u00f3n (si aplica): Joint limits # joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # For beginners, we downscale velocity and acceleration limits. # You can always specify higher scaling factors (<= 1.0) in your motion requests. # Increase the values below to 1.0 to always move at maximum speed. default_velocity_scaling_factor: 0.1 default_acceleration_scaling_factor: 0.1 # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] joint_limits: servo_joint: has_velocity_limits: false max_velocity: 0 has_acceleration_limits: false max_acceleration: 0 Y para kinematics.yaml se utiliza un plugin de moveit para su funcionamiento: Kinematics group_name: kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin kinematics_solver_search_resolution: 0.005 kinematics_solver_timeout: 0.015","title":"9. Servo Moveit"},{"location":"5-3-ServoMoveIt/#9-servo-moveit","text":"Para utilizar MoveIt se requieren m\u00faltiples archivos para su funcionamiento, estos se enlistan a continuaci\u00f3n:","title":"9. Servo Moveit"},{"location":"5-3-ServoMoveIt/#91-archivos-xacro","text":"gazebo.xacro mock.xacro servo.urdf servo.srdf Los archivos xacro a excepci\u00f3n del archivo servo.srdf , son los mismos previamente realizados y explicados, por lo que estos 3 archivos se basan simplemente en incluir los dem\u00e1s de la siguiente manera: <?xml version=\"1.0\"?> <robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" name=\"servo\"> <!-- Import panda urdf file --> <xacro:include filename=\"$(find servo_hardware)/urdf/servo.description.xacro\" /> <!-- Import servo ros2_control description --> <xacro:include filename=\"servo.ros2_control.xacro\" /> <xacro:servo_ros2_control name=\"servo\" plugin=\"servo_hardware/ServoArduinoHardware\" prefix=\"\" /> </robot> Este es el c\u00f3digo del archivo servo.urdf en donde meramente se incluye el urdf del servo y se incluye la descripci\u00f3n del hardware del robot.","title":"9.1 Archivos xacro"},{"location":"5-3-ServoMoveIt/#servosrdf","text":"El \u00fanico archivo que no se hab\u00eda mencionado hasta el momento es el servo.srdf , este archivo es una descripci\u00f3n de la cadena del robot; es decir, c\u00f3mo est\u00e1 conectado el mismo por componentes. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <!--This does not replace URDF, and is not an extension of URDF. This is a format for representing semantic information about the robot structure. A URDF file must exist for this robot as well, where the joints and the links that are referenced are defined --> <robot name=\"servo\"> <!--GROUPS: Representation of a set of joints and links. This can be useful for specifying DOF to plan for, defining arms, end effectors, etc--> <!--LINKS: When a link is specified, the parent joint of that link (if it exists) is automatically included--> <!--JOINTS: When a joint is specified, the child link of that joint (which will always exist) is automatically included--> <!--CHAINS: When a chain is specified, all the links along the chain (including endpoints) are included in the group. Additionally, all the joints that are parents to included links are also included. This means that joints along the chain and the parent joint of the base link are included in the group--> <!--SUBGROUPS: Groups can also be formed by referencing to already defined group names--> <group name=\"group_name\"> <link name=\"motor\"/> <link name=\"arm\"/> <joint name=\"servo_joint\"/> <chain base_link=\"motor\" tip_link=\"arm\"/> </group> <!--GROUP STATES: Purpose: Define a named state for a particular group, in terms of joint values. This is useful to define states like 'folded arms'--> <group_state name=\"zero\" group=\"group_name\"> <joint name=\"servo_joint\" value=\"0\"/> </group_state> <group_state name=\"p_one\" group=\"group_name\"> <joint name=\"servo_joint\" value=\"1\"/> </group_state> <group_state name=\"n_one\" group=\"group_name\"> <joint name=\"servo_joint\" value=\"-1\"/> </group_state> <!--VIRTUAL JOINT: Purpose: this element defines a virtual joint between a robot link and an external frame of reference (considered fixed with respect to the robot)--> <virtual_joint name=\"world_joint\" type=\"fixed\" parent_frame=\"world\" child_link=\"base_link\"/> <!--DISABLE COLLISIONS: By default it is assumed that any link of the robot could potentially come into collision with any other link in the robot. This tag disables collision checking between a specified pair of links. --> <disable_collisions link1=\"arm\" link2=\"motor\" reason=\"Adjacent\"/> </robot> Como se puede observar, primero se enlista el grupo o cadena del robot bajo el nombre group name en donde se enlista toda la cadena de joints y links del robot. Luego de esto se definen los group states que son b\u00e1sicamente algunos estados del robot, estas vendr\u00edan siendo unas posiciones determinadas para el movimiento del mismo; y por \u00faltimo se pueden definir dos cosas virtual joint en donde se establece un joint entre el robot y el mundo para que no vuele el robot en la simulaci\u00f3n y disable collisions en donde se definen que joints no pueden chocar por ser adyacentes o simplemente ser imposible su colisi\u00f3n.","title":"Servo.srdf"},{"location":"5-3-ServoMoveIt/#92-archivos-yaml","text":"chomp_planning.yaml ompl_planning.yaml pliz_cartesian_limits.yaml sensors.yaml moveit_controllers.yaml joint_limits.yaml kinematics.yaml Anteriormente, los archivos yaml pod\u00edan ser extra\u00eddos con el moveit assistant en ROS 1 , en el caso del servo y el scara se utilizaron los archivos extra\u00eddos previamente con ROS y se adaptaron a las necesidades propias. En MoveIt un robot se puede mover con diferentes planners , tales como chomp , ompl y pliz , estos se atribuyen a los 3 primeros archivos yaml , cada uno se diferencia en el objetivo que se requiera, por ejemplo para un movimiento con coordenadas vendr\u00eda siendo mejor un pliz ; sin embargo, en el proyecto inicialmente se utiliz\u00f3 el ompl . El archivo de sensors.yaml actualmente se encuentra vac\u00edo teniendo en cuenta que no se tienen sensores integrados al robot, el archivo de moveit_controllers.yaml se integra el controlador default de moveit y el que utilizamos para controlar el servo; es decir, el Joint trajectory controller de la siguiente manera:","title":"9.2 Archivos yaml"},{"location":"5-3-ServoMoveIt/#moveit-controllers","text":"# MoveIt uses this configuration for controller management trajectory_execution: allowed_execution_duration_scaling: 1.2 allowed_goal_duration_margin: 0.5 allowed_start_tolerance: 0.01 moveit_controller_manager: moveit_simple_controller_manager/MoveItSimpleControllerManager moveit_simple_controller_manager: controller_names: - servo_controller servo_controller: action_ns: follow_joint_trajectory type: FollowJointTrajectory default: true joints: - servo_joint Por \u00faltimo se tienen los archivos joint_limits.yaml y kinematics.yaml , para joint_limits.yaml se decriben los l\u00edmites de los joints en t\u00e9rminos meramente de velocidad y aceleraci\u00f3n (si aplica):","title":"Moveit controllers"},{"location":"5-3-ServoMoveIt/#joint-limits","text":"# joint_limits.yaml allows the dynamics properties specified in the URDF to be overwritten or augmented as needed # For beginners, we downscale velocity and acceleration limits. # You can always specify higher scaling factors (<= 1.0) in your motion requests. # Increase the values below to 1.0 to always move at maximum speed. default_velocity_scaling_factor: 0.1 default_acceleration_scaling_factor: 0.1 # Specific joint properties can be changed with the keys [max_position, min_position, max_velocity, max_acceleration] # Joint limits can be turned off with [has_velocity_limits, has_acceleration_limits] joint_limits: servo_joint: has_velocity_limits: false max_velocity: 0 has_acceleration_limits: false max_acceleration: 0 Y para kinematics.yaml se utiliza un plugin de moveit para su funcionamiento:","title":"Joint limits"},{"location":"5-3-ServoMoveIt/#kinematics","text":"group_name: kinematics_solver: kdl_kinematics_plugin/KDLKinematicsPlugin kinematics_solver_search_resolution: 0.005 kinematics_solver_timeout: 0.015","title":"Kinematics"},{"location":"5-4-ServoHardware%20y%20arduino/","text":"10. Servo hardware Harware y arduino de servo","title":"10. Servo hardware"},{"location":"5-4-ServoHardware%20y%20arduino/#10-servo-hardware","text":"Harware y arduino de servo","title":"10. Servo hardware"},{"location":"5-5-ServoLaunch/","text":"11. Servo launch Los archivos Launch son de vital importancia porque son con los que se ejecuta todo un paquete. Estos archivos normalmente se hacen en python y su funcionamiento es bastante b\u00e1sico. Su arquitectura se constituye de una funci\u00f3n general llamada `generate_launch_description` que internamente posee los definiciones con par\u00e1metros de los diferentes nodos que deseamos ejecutar. como Gazebo, Rviz, joint_state_publisher_gui, etc. Y al final, posee un return LaunchDescription con los nodos que se desean ejecutar en ese Launch. En este repositorio se encuentran distintos Launch descritos a continuaci\u00f3n: demo.launch.py: Archivo Launch general para realizar el control con el servo REAL gazebo.launch.py: Archivo Launch para realizar el control del servo en la simulaci\u00f3n con Gazebo mock.launch.py: Archivo Launch para realizar el control en Rviz con un servo FALSO Estos 3 archivos Launch son necesarios para toda la ejecuci\u00f3n y control del servo ya que son como una secuencia para el \u00e9xito del proyecto. Primero se debe asegurar que el mock.launch.py funcione correctamente, despu\u00e9s de esto se debe lograr que el gazebo.launch.py funcione para as\u00ed pasar con el Hardware Component al demo.launch.py . 11.1. Mock Launch El archivo mock.launch.py es uno de los m\u00e1s importantes porque es el primer paso para el contorl de cualquier dispositivo. Al funcionar este archivo se est\u00e1 asegurando que el planner de moveit est\u00e1 funcionando correctamente en conjunto con el URDF y los xacros . Al inicio de cualquier Launch lo primero que se tiene es la importaci\u00f3n de funciones necesarias import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument from launch.substitutions import LaunchConfiguration from launch.conditions import IfCondition, UnlessCondition from launch_ros.actions import Node from launch.actions import ExecuteProcess from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego empieza la definici\u00f3n de los nodos del Launch , comenzando con moveit_config y run_move_group_node para la configuraci\u00f3n del planner : def generate_launch_description(): # Command-line arguments db_arg = DeclareLaunchArgument( \"db\", default_value=\"False\", description=\"Database flag\" ) moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_mock.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) # Start the actual move_group node/action server run_move_group_node = Node( package=\"moveit_ros_move_group\", executable=\"move_group\", output=\"screen\", parameters=[moveit_config.to_dict()], ) Luego sigue la configuraci\u00f3n del Rviz # RViz rviz_base = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"launch\" ) rviz_full_config = os.path.join(rviz_base, \"moveit.rviz\") rviz_node = Node( package=\"rviz2\", executable=\"rviz2\", name=\"rviz2\", output=\"log\", arguments=[\"-d\", rviz_full_config], parameters=[ moveit_config.robot_description, moveit_config.robot_description_semantic, moveit_config.planning_pipelines, moveit_config.robot_description_kinematics, ], ) Luego se ingresa la posici\u00f3n inicial del robot y la definici\u00f3n del robot_state_publisher para realizar las transformaciones necesarias con el movimiento # Static TF static_tf = Node( package=\"tf2_ros\", executable=\"static_transform_publisher\", name=\"static_transform_publisher\", output=\"log\", arguments=[\"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"world\", \"base_link\"], ) # Publish TF robot_state_publisher = Node( package=\"robot_state_publisher\", executable=\"robot_state_publisher\", name=\"robot_state_publisher\", output=\"both\", parameters=[moveit_config.robot_description], ) Luego se ingresa el nodo de ros2_control con la ruta de los controladores necesarios # ros2_control using FakeSystem as hardware ros2_controllers_path = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"config\", \"ros2_controllers.yaml\", ) ros2_control_node = Node( package=\"controller_manager\", executable=\"ros2_control_node\", parameters=[moveit_config.robot_description, ros2_controllers_path], output=\"both\", ) Y la ejecuci\u00f3n de los controladores del robot joint_state_broadcaster_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"joint_state_broadcaster\", \"--controller-manager\", \"/controller_manager\", ], ) servo_controller_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"servo_controller\", \"--controller-manager\", \"/controller_manager\", ], ) # Warehouse mongodb server db_config = LaunchConfiguration(\"db\") mongodb_server_node = Node( package=\"warehouse_ros_mongo\", executable=\"mongo_wrapper_ros.py\", parameters=[ {\"warehouse_port\": 33829}, {\"warehouse_host\": \"localhost\"}, {\"warehouse_plugin\": \"warehouse_ros_mongo::MongoDatabaseConnection\"}, ], output=\"screen\", condition=IfCondition(db_config), ) Y como se mencion\u00f3 al inicio, siempre al final del Launch se llaman a los nodos que se desean activar return LaunchDescription( [ db_arg, rviz_node, static_tf, robot_state_publisher, run_move_group_node, ros2_control_node, mongodb_server_node, joint_state_broadcaster_spawner, servo_controller_spawner, ] ) 11.2. Gazebo Launch En constituci\u00f3n, todos los launch son muy similares, se diferencian en los par\u00e1metros de los distintos nodos que contienen o que por su funcionamiento \u00f3ptimo se a\u00f1ade un nodo adicional. En el caso del gazebo.launch.py , tiene las siguientes diferencias: Primero en la importaci\u00f3n de funciones: import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler from launch.event_handlers import OnProcessExit from launch.launch_description_sources import PythonLaunchDescriptionSource from launch_ros.actions import Node from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego, tiene un nodo para la ejecuci\u00f3n de Gazebo y el Serial Device para la posici\u00f3n del servo gazebo = IncludeLaunchDescription( PythonLaunchDescriptionSource([os.path.join( get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']), ) # Command-line arguments serial_arg = DeclareLaunchArgument( \"port\", default_value=\"/dev/ttyACM0\", description=\"Puerto comunicacion serial\" ) Para la simulaci\u00f3n se habilita el tiempo de la misma con el par\u00e1metro use_sim_time use_sim_time = {\"use_sim_time\":True} moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_gazebo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) config_dict = moveit_config.to_dict() config_dict.update(use_sim_time) Se a\u00f1ade un nodo para spawnear la entidad en el entorno de simulaci\u00f3n de Gazebo spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py', arguments=['-topic', 'robot_description','-entity', 'servo'], output='screen') Y por \u00faltimo entre la ejecuci\u00f3n de los controladores se a\u00f1ade un delay para evitar un fallo entre los mismos #NODO DE JOINT_STATE_BROADCASTER delayed_joint_state_broadcaster_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=spawn_entity, on_exit=[joint_state_broadcaster_spawner], ) ) #NODO DE SERVO_CONTROLLER delayed_servo_controller_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=joint_state_broadcaster_spawner, on_exit=[servo_controller_spawner], ) ) 11.3. Demo Launch El demo Launch es el archivo que se utiliza para controlar con el servo REAL conectado. Curiosamente, es un Launch muy similar al mock.launch.py y solo existe una diferencia entre estos dos archivos: moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) En vez de tomar servo_mock.urdf.xacro , se toma el servo.urdf.xacro de la carpeta config. Con esto ya no se estar\u00eda tomando el plugin de un servo FALSO sino el plugin constituido en C++ para el servo REAL .","title":"11. Servo launch"},{"location":"5-5-ServoLaunch/#11-servo-launch","text":"Los archivos Launch son de vital importancia porque son con los que se ejecuta todo un paquete. Estos archivos normalmente se hacen en python y su funcionamiento es bastante b\u00e1sico. Su arquitectura se constituye de una funci\u00f3n general llamada `generate_launch_description` que internamente posee los definiciones con par\u00e1metros de los diferentes nodos que deseamos ejecutar. como Gazebo, Rviz, joint_state_publisher_gui, etc. Y al final, posee un return LaunchDescription con los nodos que se desean ejecutar en ese Launch. En este repositorio se encuentran distintos Launch descritos a continuaci\u00f3n: demo.launch.py: Archivo Launch general para realizar el control con el servo REAL gazebo.launch.py: Archivo Launch para realizar el control del servo en la simulaci\u00f3n con Gazebo mock.launch.py: Archivo Launch para realizar el control en Rviz con un servo FALSO Estos 3 archivos Launch son necesarios para toda la ejecuci\u00f3n y control del servo ya que son como una secuencia para el \u00e9xito del proyecto. Primero se debe asegurar que el mock.launch.py funcione correctamente, despu\u00e9s de esto se debe lograr que el gazebo.launch.py funcione para as\u00ed pasar con el Hardware Component al demo.launch.py .","title":"11. Servo launch"},{"location":"5-5-ServoLaunch/#111-mock-launch","text":"El archivo mock.launch.py es uno de los m\u00e1s importantes porque es el primer paso para el contorl de cualquier dispositivo. Al funcionar este archivo se est\u00e1 asegurando que el planner de moveit est\u00e1 funcionando correctamente en conjunto con el URDF y los xacros . Al inicio de cualquier Launch lo primero que se tiene es la importaci\u00f3n de funciones necesarias import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument from launch.substitutions import LaunchConfiguration from launch.conditions import IfCondition, UnlessCondition from launch_ros.actions import Node from launch.actions import ExecuteProcess from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego empieza la definici\u00f3n de los nodos del Launch , comenzando con moveit_config y run_move_group_node para la configuraci\u00f3n del planner : def generate_launch_description(): # Command-line arguments db_arg = DeclareLaunchArgument( \"db\", default_value=\"False\", description=\"Database flag\" ) moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_mock.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) # Start the actual move_group node/action server run_move_group_node = Node( package=\"moveit_ros_move_group\", executable=\"move_group\", output=\"screen\", parameters=[moveit_config.to_dict()], ) Luego sigue la configuraci\u00f3n del Rviz # RViz rviz_base = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"launch\" ) rviz_full_config = os.path.join(rviz_base, \"moveit.rviz\") rviz_node = Node( package=\"rviz2\", executable=\"rviz2\", name=\"rviz2\", output=\"log\", arguments=[\"-d\", rviz_full_config], parameters=[ moveit_config.robot_description, moveit_config.robot_description_semantic, moveit_config.planning_pipelines, moveit_config.robot_description_kinematics, ], ) Luego se ingresa la posici\u00f3n inicial del robot y la definici\u00f3n del robot_state_publisher para realizar las transformaciones necesarias con el movimiento # Static TF static_tf = Node( package=\"tf2_ros\", executable=\"static_transform_publisher\", name=\"static_transform_publisher\", output=\"log\", arguments=[\"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"0.0\", \"world\", \"base_link\"], ) # Publish TF robot_state_publisher = Node( package=\"robot_state_publisher\", executable=\"robot_state_publisher\", name=\"robot_state_publisher\", output=\"both\", parameters=[moveit_config.robot_description], ) Luego se ingresa el nodo de ros2_control con la ruta de los controladores necesarios # ros2_control using FakeSystem as hardware ros2_controllers_path = os.path.join( get_package_share_directory(\"servo_hardware_moveit_config\"), \"config\", \"ros2_controllers.yaml\", ) ros2_control_node = Node( package=\"controller_manager\", executable=\"ros2_control_node\", parameters=[moveit_config.robot_description, ros2_controllers_path], output=\"both\", ) Y la ejecuci\u00f3n de los controladores del robot joint_state_broadcaster_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"joint_state_broadcaster\", \"--controller-manager\", \"/controller_manager\", ], ) servo_controller_spawner = Node( package=\"controller_manager\", executable=\"spawner\", arguments=[ \"servo_controller\", \"--controller-manager\", \"/controller_manager\", ], ) # Warehouse mongodb server db_config = LaunchConfiguration(\"db\") mongodb_server_node = Node( package=\"warehouse_ros_mongo\", executable=\"mongo_wrapper_ros.py\", parameters=[ {\"warehouse_port\": 33829}, {\"warehouse_host\": \"localhost\"}, {\"warehouse_plugin\": \"warehouse_ros_mongo::MongoDatabaseConnection\"}, ], output=\"screen\", condition=IfCondition(db_config), ) Y como se mencion\u00f3 al inicio, siempre al final del Launch se llaman a los nodos que se desean activar return LaunchDescription( [ db_arg, rviz_node, static_tf, robot_state_publisher, run_move_group_node, ros2_control_node, mongodb_server_node, joint_state_broadcaster_spawner, servo_controller_spawner, ] )","title":"11.1. Mock Launch"},{"location":"5-5-ServoLaunch/#112-gazebo-launch","text":"En constituci\u00f3n, todos los launch son muy similares, se diferencian en los par\u00e1metros de los distintos nodos que contienen o que por su funcionamiento \u00f3ptimo se a\u00f1ade un nodo adicional. En el caso del gazebo.launch.py , tiene las siguientes diferencias: Primero en la importaci\u00f3n de funciones: import os from launch import LaunchDescription from launch.actions import DeclareLaunchArgument, IncludeLaunchDescription, RegisterEventHandler from launch.event_handlers import OnProcessExit from launch.launch_description_sources import PythonLaunchDescriptionSource from launch_ros.actions import Node from ament_index_python.packages import get_package_share_directory from moveit_configs_utils import MoveItConfigsBuilder Luego, tiene un nodo para la ejecuci\u00f3n de Gazebo y el Serial Device para la posici\u00f3n del servo gazebo = IncludeLaunchDescription( PythonLaunchDescriptionSource([os.path.join( get_package_share_directory('gazebo_ros'), 'launch'), '/gazebo.launch.py']), ) # Command-line arguments serial_arg = DeclareLaunchArgument( \"port\", default_value=\"/dev/ttyACM0\", description=\"Puerto comunicacion serial\" ) Para la simulaci\u00f3n se habilita el tiempo de la misma con el par\u00e1metro use_sim_time use_sim_time = {\"use_sim_time\":True} moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo_gazebo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .robot_description_kinematics(file_path=\"config/kinematics.yaml\") .to_moveit_configs() ) config_dict = moveit_config.to_dict() config_dict.update(use_sim_time) Se a\u00f1ade un nodo para spawnear la entidad en el entorno de simulaci\u00f3n de Gazebo spawn_entity = Node(package='gazebo_ros', executable='spawn_entity.py', arguments=['-topic', 'robot_description','-entity', 'servo'], output='screen') Y por \u00faltimo entre la ejecuci\u00f3n de los controladores se a\u00f1ade un delay para evitar un fallo entre los mismos #NODO DE JOINT_STATE_BROADCASTER delayed_joint_state_broadcaster_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=spawn_entity, on_exit=[joint_state_broadcaster_spawner], ) ) #NODO DE SERVO_CONTROLLER delayed_servo_controller_spawner = RegisterEventHandler( event_handler=OnProcessExit( target_action=joint_state_broadcaster_spawner, on_exit=[servo_controller_spawner], ) )","title":"11.2. Gazebo Launch"},{"location":"5-5-ServoLaunch/#113-demo-launch","text":"El demo Launch es el archivo que se utiliza para controlar con el servo REAL conectado. Curiosamente, es un Launch muy similar al mock.launch.py y solo existe una diferencia entre estos dos archivos: moveit_config = ( MoveItConfigsBuilder(\"servo_hardware\") .robot_description(file_path=\"config/servo.urdf.xacro\") .robot_description_semantic(file_path=\"config/servo.srdf\") .trajectory_execution(file_path=\"config/moveit_controllers.yaml\") .to_moveit_configs() ) En vez de tomar servo_mock.urdf.xacro , se toma el servo.urdf.xacro de la carpeta config. Con esto ya no se estar\u00eda tomando el plugin de un servo FALSO sino el plugin constituido en C++ para el servo REAL .","title":"11.3. Demo Launch"},{"location":"Using%20Moveit%20Assitant/","text":"Usando el asistente de Moveit Para poder usar Moveit2 debemos crear unos archivos de configuraci\u00f3n necesarios para correr moveit. Estos archivos se pueden generar en el Moveit-Assitant, lamentablemente este asistente solo est\u00e1 disponible en ROS1, por lo que tendremos que instalarlo. Para hacer la instalaci\u00f3n de ROS1 en nuestro Ubuntu 22.04 y no tener problemas con nuestra instalaci\u00f3n de ROS2, lo instalaremos en una ambiente virtual creado con mamba ( una versi\u00f3n m\u00e1s r\u00e1pide de Anaconda ). Instalando mamba para gestionar los ambientes virtuales Inicialmente tendremos que instalar mamba . Tomado de aqu\u00ed , ejecutaremos los siguientes comandos: curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-Linux-x86_64.sh\" bash Mambaforge-Linux-x86_64.sh Una vez instalado vamos a ir a la carpeta mambaforge/bin y ejecutaremos los siguientes comandos para activar mamba: ./conda init ./conda config --set auto_activate_base false Reiniciamos el terminal y ahora podemos continuar con la instalaci\u00f3n de ROS1 La instalaci\u00f3n de ROS1 en un ambiente virtual Secci\u00f3n inspirada en la documentaci\u00f3n de RoboStack Inicialmente vamos a crear el ambiente virtual, como la versi\u00f3n de ROS1 que vamos a instalar es la noetic, creare el ambiente virtual con el siguiente comando: mamba create -n noetic_env mamba init Luego de reiniciar el terminal, activaremos el ambiente virtual: mamba activate noetic_env Prepararemos el ambiente para instalar ROS1 de los repositorios correctos: # this adds the conda-forge channel to the new created environment configuration conda config --env --add channels conda-forge # and the robostack channel conda config --env --add channels robostack-staging # remove the defaults channel just in case, this might return an error if it is not in the list which is ok conda config --env --remove channels defaults El \u00faltimo comando puede generar un error por que algunas veces no existe, entonces no puede ser removido. Ya tenemos entonces el ambiente listo para instalar ROS1, que instalaremos con el siguiente comando: # Install ros-noetic into the environment (ROS1) mamba install ros-noetic-desktop # Install tools for local development mamba install compilers cmake pkg-config make ninja colcon-common-extensions catkin_tools Para poder usar ROS1, debemos desactivar ROS2 del archivo ~/.bashrc , esto lo haremos comentando la linea mostrada a continuaci\u00f3n: # source /opt/ros/humble/setup.bash y reiniciando el terminal. Probando la instalaci\u00f3n En dos terminales haremos lo siguiente: En el terminal 1, activaremos el ambiente y luego correremos el comando roscore que inicia el proceso principal de ROS1: bash mamba activate noetic_env roscore En el terminal 2, activaremos el ambiente y correremos el comando de rviz: bash mamba activate noetic_env rviz Instalando Moveit para ROS1 Estando dentro del ambiente virtual ( noetic_env ), vamos a instalar moveit con el siguiente comando: mamba install ros-noetic-moveit Una vez instalado podremos correr el assistente para moveit con el siguiente comando: roslaunch moveit_setup_assistant setup_assistant.launch Usando el asistente de MoveIt https://www.youtube.com/watch?v=EosEikbZhiM Para usar el asistente necesitaremos un archivo \"URDF\" : ros2 topic echo /robot_description -l 1000000000 > data.urdf","title":"Usando el asistente de Moveit"},{"location":"Using%20Moveit%20Assitant/#usando-el-asistente-de-moveit","text":"Para poder usar Moveit2 debemos crear unos archivos de configuraci\u00f3n necesarios para correr moveit. Estos archivos se pueden generar en el Moveit-Assitant, lamentablemente este asistente solo est\u00e1 disponible en ROS1, por lo que tendremos que instalarlo. Para hacer la instalaci\u00f3n de ROS1 en nuestro Ubuntu 22.04 y no tener problemas con nuestra instalaci\u00f3n de ROS2, lo instalaremos en una ambiente virtual creado con mamba ( una versi\u00f3n m\u00e1s r\u00e1pide de Anaconda ).","title":"Usando el asistente de Moveit"},{"location":"Using%20Moveit%20Assitant/#instalando-mamba-para-gestionar-los-ambientes-virtuales","text":"Inicialmente tendremos que instalar mamba . Tomado de aqu\u00ed , ejecutaremos los siguientes comandos: curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-Linux-x86_64.sh\" bash Mambaforge-Linux-x86_64.sh Una vez instalado vamos a ir a la carpeta mambaforge/bin y ejecutaremos los siguientes comandos para activar mamba: ./conda init ./conda config --set auto_activate_base false Reiniciamos el terminal y ahora podemos continuar con la instalaci\u00f3n de ROS1","title":"Instalando mamba para gestionar los ambientes virtuales"},{"location":"Using%20Moveit%20Assitant/#la-instalacion-de-ros1-en-un-ambiente-virtual","text":"Secci\u00f3n inspirada en la documentaci\u00f3n de RoboStack Inicialmente vamos a crear el ambiente virtual, como la versi\u00f3n de ROS1 que vamos a instalar es la noetic, creare el ambiente virtual con el siguiente comando: mamba create -n noetic_env mamba init Luego de reiniciar el terminal, activaremos el ambiente virtual: mamba activate noetic_env Prepararemos el ambiente para instalar ROS1 de los repositorios correctos: # this adds the conda-forge channel to the new created environment configuration conda config --env --add channels conda-forge # and the robostack channel conda config --env --add channels robostack-staging # remove the defaults channel just in case, this might return an error if it is not in the list which is ok conda config --env --remove channels defaults El \u00faltimo comando puede generar un error por que algunas veces no existe, entonces no puede ser removido. Ya tenemos entonces el ambiente listo para instalar ROS1, que instalaremos con el siguiente comando: # Install ros-noetic into the environment (ROS1) mamba install ros-noetic-desktop # Install tools for local development mamba install compilers cmake pkg-config make ninja colcon-common-extensions catkin_tools Para poder usar ROS1, debemos desactivar ROS2 del archivo ~/.bashrc , esto lo haremos comentando la linea mostrada a continuaci\u00f3n: # source /opt/ros/humble/setup.bash y reiniciando el terminal.","title":"La instalaci\u00f3n de ROS1 en un ambiente virtual"},{"location":"Using%20Moveit%20Assitant/#probando-la-instalacion","text":"En dos terminales haremos lo siguiente: En el terminal 1, activaremos el ambiente y luego correremos el comando roscore que inicia el proceso principal de ROS1: bash mamba activate noetic_env roscore En el terminal 2, activaremos el ambiente y correremos el comando de rviz: bash mamba activate noetic_env rviz","title":"Probando la instalaci\u00f3n"},{"location":"Using%20Moveit%20Assitant/#instalando-moveit-para-ros1","text":"Estando dentro del ambiente virtual ( noetic_env ), vamos a instalar moveit con el siguiente comando: mamba install ros-noetic-moveit Una vez instalado podremos correr el assistente para moveit con el siguiente comando: roslaunch moveit_setup_assistant setup_assistant.launch","title":"Instalando Moveit para ROS1"},{"location":"Using%20Moveit%20Assitant/#usando-el-asistente-de-moveit_1","text":"https://www.youtube.com/watch?v=EosEikbZhiM Para usar el asistente necesitaremos un archivo \"URDF\" : ros2 topic echo /robot_description -l 1000000000 > data.urdf","title":"Usando el asistente de MoveIt"}]}